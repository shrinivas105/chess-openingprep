<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Lines of the Legion</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background:linear-gradient(135deg,#0f0f0f 0%,#1a1a1a 100%);color:#fff;min-height:100vh;display:flex;flex-direction:column;align-items:center;padding:10px;touch-action:manipulation}
    .menu{text-align:center;padding:40px 20px;background:rgba(30,30,30,.95);border-radius:20px;max-width:500px;margin:20px auto;box-shadow:0 8px 32px rgba(0,0,0,.4);border:1px solid rgba(129,182,76,.2)}
    .menu h2{font-size:2.5rem;margin-bottom:20px;background:linear-gradient(135deg,#81b64c,#5d8a33);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .menu p{font-size:1.1rem;color:#eee;margin-bottom:20px;line-height:1.8}
    .menu-btn{width:100%;max-width:280px;padding:18px;margin:8px 10px;background:linear-gradient(135deg,#81b64c,#6ea03d);color:#fff;border:none;border-radius:12px;font-size:1rem;font-weight:bold;box-shadow:0 6px 0 #4a7028,0 8px 20px rgba(129,182,76,.3);cursor:pointer;transition:all .2s ease}
    .menu-btn:hover{transform:translateY(-2px);box-shadow:0 8px 0 #4a7028,0 12px 24px rgba(129,182,76,.4)}
    .menu-btn:active{transform:translateY(4px);box-shadow:0 2px 0 #4a7028,0 4px 12px rgba(129,182,76,.3)}
    #resetBtn{background:linear-gradient(135deg,#e74c3c,#c0392b);box-shadow:0 6px 0 #8b2e24,0 8px 20px rgba(231,76,60,.3)}
    #resetBtn:hover{box-shadow:0 8px 0 #8b2e24,0 12px 24px rgba(231,76,60,.4)!important}
    .game-container{display:flex;flex-direction:column;align-items:center;width:100%;max-width:500px;background:rgba(20,20,20,.6);border-radius:16px;padding:15px;min-height:560px}
    .board-wrapper{width:100%;max-width:400px;min-height:400px;aspect-ratio:1;display:grid;grid-template-columns:repeat(8,1fr);border:4px solid #2a2a2a;border-radius:8px;margin:20px 0}
    .square{aspect-ratio:1;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all .15s ease}
    .square.light{background:#f0d9b5}
    .square.dark{background:#b58863}
    .square.selected{background:#f6e58d!important;box-shadow:inset 0 0 0 4px #f39c12}
    .square.last-move{background:rgba(255,215,0,.4)!important}
    .square.disabled{pointer-events:none}
    .piece{width:85%;height:85%;filter:drop-shadow(0 2px 3px rgba(0,0,0,.4));pointer-events:none}
    .btn{padding:12px 25px;background:linear-gradient(135deg,#81b64c,#6ea03d);color:#fff;border:none;border-radius:8px;font-weight:bold;cursor:pointer;transition:all .2s ease}
    .btn:disabled{background:linear-gradient(135deg,#555,#444);opacity:.6}
    .theory-message,.end-summary{background:rgba(40,40,40,.95);padding:15px 20px;border-radius:10px;margin:15px 0;width:100%;max-width:500px;text-align:center;border:1px solid rgba(129,182,76,.3);line-height:1.6}
    .demotion-message{background:rgba(200,30,30,.9);padding:15px;border-radius:10px;margin:15px 0;font-weight:bold;border:1px solid #ff4444}
    .stats-display{background:rgba(50,50,50,.8);padding:12px 20px;border-radius:10px;margin:10px 0;border:1px solid rgba(129,182,76,.3);font-size:.95rem;line-height:1.6}
    .rank-progress{display:flex;justify-content:center;gap:6px;margin:12px 0;flex-wrap:wrap}
    .rank-step{padding:6px 12px;border-radius:8px;background:rgba(50,50,50,.6);font-size:.9rem}
    .rank-step.active{background:linear-gradient(135deg,#81b64c,#5d8a33);color:#111;font-weight:bold}
    .battle-history{background:rgba(50,50,50,.8);padding:15px 20px;border-radius:10px;margin:15px 0;border:1px solid rgba(129,182,76,.3)}
    .battle-history-title{font-size:1rem;font-weight:bold;margin-bottom:10px;color:#81b64c}
    .battle-badges{display:flex;justify-content:center;gap:8px;flex-wrap:wrap;margin:10px 0}
    .battle-badge{padding:8px 12px;border-radius:8px;font-weight:bold;font-size:.95rem}
    .battle-badge.levy{background:#e74c3c;color:#fff}
    .battle-badge.hastatus{background:#e67e22;color:#fff}
    .battle-badge.principes{background:#f39c12;color:#222}
    .battle-badge.triarius{background:#27ae60;color:#fff}
    .battle-badge.imperator{background:#f1c40f;color:#222}
    .warning-message{background:rgba(231,76,60,.15);border:2px solid #e74c3c;padding:12px;border-radius:8px;margin-top:12px;font-size:.9rem;font-weight:bold;color:#ff6b6b}
    .game-list-item{margin:12px 0;padding:14px;background:rgba(50,50,50,.8);border-radius:10px;text-align:left;font-size:.9rem;border:1px solid rgba(129,182,76,.2);transition:all .2s ease}
  </style>
</head>
<body>
  <div id="app"></div>
  <script>
    const pieces = {
      wp: "https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg",
      wr: "https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg",
      wn: "https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg",
      wb: "https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg",
      wq: "https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg",
      wk: "https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg",
      bp: "https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg",
      br: "https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg",
      bn: "https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg",
      bb: "https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg",
      bq: "https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg",
      bk: "https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg"
    };

    class ChessAPI {
      static cache = {};

      static async queryExplorer(source, fen) {
        const key = `${source}_${fen}`;
        if (this.cache[key]) return this.cache[key];
        let url = source === 'master' ? 'https://explorer.lichess.ovh/masters' : 'https://explorer.lichess.ovh/lichess';
        url += `?variant=standard&fen=${encodeURIComponent(fen)}&topGames=0&moves=5`;
        if (source === 'lichess') url += '&ratings=1600,1800,2000,2200,2500';
        try {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 6000);
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timeout);
          if (!response.ok) throw new Error('API error');
          const data = await response.json();
          this.cache[key] = data;
          return data;
        } catch (e) {
          console.warn('Explorer failed:', e);
          return { white: 0, draws: 0, black: 0, moves: [] };
        }
      }

      static async queryGames(source, fen) {
        const base = source === 'master' ? 'masters' : 'lichess';
        let url = `https://explorer.lichess.ovh/${base}?variant=standard&fen=${encodeURIComponent(fen)}`;
        if (source === 'master') url += '&topGames=10';
        else url += '&recentGames=10&ratings=1600,1800,2000,2200,2500';
        try {
          const response = await fetch(url);
          if (!response.ok) return { topGames: [], recentGames: [] };
          const data = await response.json();
          return { topGames: data.topGames || [], recentGames: data.recentGames || [] };
        } catch (e) {
          console.warn('Games query failed:', e);
          return { topGames: [], recentGames: [] };
        }
      }

      static async getEvaluation(fen, cache = {}) {
        if (cache[fen] !== undefined) return cache[fen];
        try {
          const response = await fetch('https://chess-api.com/v1', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fen })
          });
          if (response.ok) {
            const data = await response.json();
            if (typeof data.eval === 'number') {
              cache[fen] = data.eval;
              return data.eval;
            }
          }
        } catch (e) {
          console.log('Evaluation unavailable');
        }
        return 0;
      }
    }

    class Scoring {
      static getPlayerEval(e, c) { return c === 'b' ? -e : e; }
      static getMoveQuality(t, p) { return p > 0 ? Math.round((t / p) * 100) : 0; }
      static getTotalScore(m, t, e) {
        const ms = m * 4 * 0.25;
        const qs = this.getMoveQuality(t, m) * 0.40;
        const es = e < -3 ? 0 : Math.max(0, (e + 3) * 12 * 0.35);
        let b = ms + qs + es;
        let mul = 1, r = '';
        if (e < -3) { mul = 0.3; r = 'Catastrophic blunder! Position collapsed (eval < -3.0).'; }
        else if (e >= -3 && e < -1.5) { mul = 0.8; r = 'Significant disadvantage (eval -3.0 to -1.5).'; }
        const s = Math.min(Math.round(b * mul), mul === 0.3 ? 30 : mul === 0.8 ? 60 : 100);
        return { score: s, penaltyReason: r };
      }
      static getBattleRank(s, e, r) {
        const t = [85, 70, 55, 40];
        let n;
        if (e <= -3) n = 'Levy';
        else if (e < -1.5) n = s >= t[3] ? 'Hastatus' : 'Levy';
        else n = s >= t[0] ? 'Imperator' : s >= t[1] ? 'Triarius' : s >= t[2] ? 'Principes' : s >= t[3] ? 'Hastatus' : 'Levy';
        const rks = {
          Levy: { icon: "ü™∂", title: "Levy", msg: r || "You barely stepped onto the battlefield.", sub: "Blunders reset your rank." },
          Hastatus: { icon: "üõ°Ô∏è", title: "Hastatus", msg: r || "Frontline soldier holding formation.", sub: "Good start ‚Äî improve execution." },
          Principes: { icon: "‚öîÔ∏è", title: "Principes", msg: "You commanded with structure and intent.", sub: "Solid theory and tactics." },
          Triarius: { icon: "ü¶Ö", title: "Triarius", msg: "Veteran presence ‚Äî turning the tide.", sub: "Excellent mastery of opening & position." },
          Imperator: { icon: "üèÜ", title: "Imperator", msg: "Master of war ‚Äî architect of victory.", sub: "Perfect theory + execution." }
        };
        return { ...rks[n], score: s, penaltyReason: r };
      }
      static getLegionRank(m = 0) {
        const th = [100, 250, 500, 900, 1500];
        const ro = ['Recruit', 'Legionary', 'Optio', 'Centurion', 'Tribunus', 'Legatus'];
        let l = 0;
        for (let i = 0; i < th.length; i++) if (m >= th[i]) l = i + 1; else break;
        const n = ro[l];
        const rk = { Recruit: { title: "Recruit", icon: "üå±" }, Legionary: { title: "Legionary", icon: "üõ°Ô∏è" }, Optio: { title: "Optio", icon: "‚öîÔ∏è" }, Centurion: { title: "Centurion", icon: "ü¶Ö" }, Tribunus: { title: "Tribunus", icon: "üèÖ" }, Legatus: { title: "Legatus", icon: "üèÜ" } };
        let nr = null, pn = 0;
        if (l < ro.length - 1) { nr = ro[l + 1]; pn = th[l] - m; if (pn < 0) pn = 0; }
        return { ...rk[n], merit: m, nextRank: nr, pointsNeeded: pn, rankOrder: ro, thresholds: th };
      }
      static getDemotionWarning(r, b) {
        if (r === 'Recruit' || b.length === 0) return null;
        const l = b.filter(x => x === 'Levy').length;
        const h = b.filter(x => x === 'Hastatus').length;
        const p = b.filter(x => x === 'Principes').length;
        let w = null;
        if (r === 'Legionary') { if (l === 2) w = '‚ö†Ô∏è Warning: 2 Levy ranks - one more Levy = demotion!'; }
        else if (r === 'Optio') {
          if (l === 2) w = '‚ö†Ô∏è Warning: 2 Levy ranks - one more Levy (to make 3) OR one Hastatus = demotion!';
          else if (l === 1 && h === 1) w = '‚ö†Ô∏è Warning: 1 Levy + 1 Hastatus - one more Levy = demotion!';
        }
        else if (r === 'Centurion' || r === 'Tribunus') { if (l + h === 2) w = '‚ö†Ô∏è Warning: 2 weak battles (Levy/Hastatus) - one more = demotion!'; }
        else if (r === 'Legatus') { if (l + h + p === 2) w = '‚ö†Ô∏è Warning: 2 subpar battles - one more weak rank = demotion!'; }
        return w;
      }
    }

    class ChessTheoryApp {
      constructor() {
        this.game = new Chess();
        this.playerColor = null;
        this.aiSource = null;
        this.selected = null;
        this.lastMove = { from: null, to: null };
        this.gameCount = 0;
        this.evalCache = {};
        this.lastAIMoveFEN = null;
        this.playerMoves = 0;
        this.topMoveChoices = 0;
        this.hintUsed = false;
        this.previousFEN = null;
        this.lastPlayerUCI = null;
        this.topGames = [];
        this.recentGames = [];
        this.pieceImages = pieces;
        this.legionMerits = JSON.parse(localStorage.getItem('chessTheoryLegionMerits') || '{}');
        this.gamesPlayed = parseInt(localStorage.getItem('chessTheoryGamesPlayed') || '0');
        this.recentBattleRanksMaster = JSON.parse(localStorage.getItem('chessTheoryRecentBattleRanksMaster') || '[]');
        this.recentBattleRanksLichess = JSON.parse(localStorage.getItem('chessTheoryRecentBattleRanksLichess') || '[]');
        this.demotionMessage = null;
        this.render();
      }

      getRecentBattleRanks(source) {
        return source === 'master' ? this.recentBattleRanksMaster : this.recentBattleRanksLichess;
      }

      setRecentBattleRanks(source, ranks) {
        if (source === 'master') {
          this.recentBattleRanksMaster = ranks;
          localStorage.setItem('chessTheoryRecentBattleRanksMaster', JSON.stringify(ranks));
        } else {
          this.recentBattleRanksLichess = ranks;
          localStorage.setItem('chessTheoryRecentBattleRanksLichess', JSON.stringify(ranks));
        }
      }

      renderBattleHistory(source) {
        const meritKey = `${source}_merit`;
        const currentMerit = this.legionMerits[meritKey] || 0;
        const legionInfo = Scoring.getLegionRank(currentMerit);
        const recentRanks = this.getRecentBattleRanks(source);
        const warning = Scoring.getDemotionWarning(legionInfo.title, recentRanks);
        if (recentRanks.length === 0) return '';
        const battleBadges = recentRanks.map(rank => {
          const letter = rank[0];
          const className = rank.toLowerCase();
          return `<div class="battle-badge ${className}">${letter}</div>`;
        }).join('');
        return `
          <div class="battle-history">
            <div class="battle-history-title">Last ${recentRanks.length} Battle${recentRanks.length > 1 ? 's' : ''}</div>
            <div class="battle-badges">${battleBadges}</div>
            ${warning ? `<div class="warning-message">${warning}</div>` : ''}
          </div>
        `;
      }

      renderMenu() {
        const masterMerit = this.legionMerits.master_merit || 0;
        const clubMerit = this.legionMerits.lichess_merit || 0;
        const masterLegion = Scoring.getLegionRank(masterMerit);
        const clubLegion = Scoring.getLegionRank(clubMerit);
        const masterBattleHistory = this.renderBattleHistory('master');
        const clubBattleHistory = this.renderBattleHistory('lichess');
        document.getElementById('app').innerHTML = `
          <div class="menu">
            <h2>Lines of the Legion</h2>
            <p>Hold the line. Survive the opening battle drawn from real games ‚Äî until theory ends and novelty begins.</p>
            <div class="stats-display">
              <div><strong>üèÜ Masters Legion:</strong> ${masterLegion.title} (${masterMerit} merit) ${masterLegion.icon}<br>${masterLegion.nextRank ? `${masterLegion.title} ‚Üí ${masterLegion.nextRank}: ${masterLegion.pointsNeeded} more merit` : 'Highest rank achieved!'}</div>
              <div class="rank-progress">${masterLegion.rankOrder.map(r => `<div class="rank-step ${r === masterLegion.title ? 'active' : ''}">${r}</div>`).join('')}</div>
              ${masterBattleHistory}
              <div><strong>‚ôüÔ∏è Club Legion:</strong> ${clubLegion.title} (${clubMerit} merit) ${clubLegion.icon}<br>${clubLegion.nextRank ? `${clubLegion.title} ‚Üí ${clubLegion.nextRank}: ${clubLegion.pointsNeeded} more merit` : 'Highest rank achieved!'}</div>
              <div class="rank-progress">${clubLegion.rankOrder.map(r => `<div class="rank-step ${r === clubLegion.title ? 'active' : ''}">${r}</div>`).join('')}</div>
              ${clubBattleHistory}
              <div>‚öîÔ∏è Battles Fought: ${this.gamesPlayed}</div>
            </div>
            <p>I want to fight a,</p>
            <button id="masterBtn" class="menu-btn">üèÜ Master</button>
            <button id="lichessBtn" class="menu-btn">‚ôüÔ∏è Club Rookie</button>
            <button id="resetBtn" class="menu-btn">üîÑ Reset Stats</button>
            <div style="margin-top:40px;font-size:.9rem;color:#ccc;font-style:italic;">Author: Srinivas Kulkarni</div>
          </div>
        `;
        document.getElementById('masterBtn').onclick = () => this.selectSource('master');
        document.getElementById('lichessBtn').onclick = () => this.selectSource('lichess');
        document.getElementById('resetBtn').onclick = () => this.resetStats();
      }

      renderColorChoice() {
        document.getElementById('app').innerHTML = `
          <div class="menu">
            <h2>Play As</h2>
            <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
              <button id="whiteBtn" class="menu-btn" style="max-width:140px;background:#eee;color:#222;">White</button>
              <button id="blackBtn" class="menu-btn" style="max-width:140px;background:#444;">Black</button>
            </div>
          </div>
        `;
        document.getElementById('whiteBtn').onclick = () => this.selectColor('w');
        document.getElementById('blackBtn').onclick = () => this.selectColor('b');
      }

      renderGameContainer() {
        if (document.querySelector('.game-container')) return;
        document.getElementById('app').innerHTML = `
          <div class="game-container">
            <div class="board-wrapper" id="board"></div>
            <div style="font-size:.95rem;color:#ddd;margin:10px 0;text-align:center;font-weight:500;" id="gameCount">Loading position data...</div>
            <div id="endSummary" class="end-summary" style="display:none;"></div>
            <div id="theoryMessage" class="theory-message" style="display:none;"></div>
            <div style="margin-top:20px;display:flex;gap:10px;flex-wrap:wrap;justify-content:center;">
              <button class="btn" onclick="location.reload()">üîÑ New Battle</button>
              <button class="btn" id="hintBtn">üéñÔ∏è Consult the Commander</button>
            </div>
          </div>
        `;
      }

      renderBoard() {
        this.renderGameContainer();
        const board = this.game.board();
        const isFlipped = this.playerColor === 'b';
        const renderedBoard = isFlipped ? board.slice().reverse().map(r => r.slice().reverse()) : board;
        const isPlayerTurn = this.game.turn() === this.playerColor;

        const countEl = document.getElementById('gameCount');
        if (countEl) {
          countEl.textContent = this.gameCount > 0 
            ? `This battle position was reached ${this.gameCount.toLocaleString()} times in history.`
            : 'Position data temporarily unavailable ‚Äî continuing anyway...';
        }

        const hintBtn = document.getElementById('hintBtn');
        if (hintBtn) {
          hintBtn.disabled = !isPlayerTurn || this.hintUsed;
          hintBtn.textContent = this.hintUsed ? '‚úì Commander Consulted' : 'üéñÔ∏è Consult the Commander';
          hintBtn.onclick = isPlayerTurn && !this.hintUsed ? () => this.getHints() : null;
        }

        const boardEl = document.getElementById('board');
        if (!boardEl) return;
        boardEl.innerHTML = '';
        renderedBoard.forEach((row, r) => {
          row.forEach((square, c) => {
            const actualRow = isFlipped ? 7 - r : r;
            const actualCol = isFlipped ? 7 - c : c;
            const sqName = 'abcdefgh'[actualCol] + (8 - actualRow);
            const isLight = (actualRow + actualCol) % 2 === 0;
            const isSelected = this.selected === sqName;
            const isLastMove = this.lastMove.from === sqName || this.lastMove.to === sqName;
            const div = document.createElement('div');
            div.className = `square ${isLight ? 'light' : 'dark'} ${isSelected ? 'selected' : ''} ${isLastMove ? 'last-move' : ''} ${!isPlayerTurn ? 'disabled' : ''}`;
            div.onclick = () => this.handleClick(actualRow, actualCol);
            if (square) {
              const img = document.createElement('img');
              img.src = this.pieceImages[square.color + square.type];
              img.className = 'piece';
              div.appendChild(img);
            }
            boardEl.appendChild(div);
          });
        });
      }

      selectSource(source) {
        this.aiSource = source;
        this.render();
      }

      selectColor(color) {
        this.playerColor = color;
        this.hintUsed = false;
        this.resetGameState();
        this.render();
      }

      resetGameState() {
        this.game.reset();
        this.selected = null;
        this.lastMove = { from: null, to: null };
        this.gameCount = 0;
        this.playerMoves = 0;
        this.topMoveChoices = 0;
        this.hintUsed = false;
        this.previousFEN = null;
        this.lastPlayerUCI = null;
        this.lastAIMoveFEN = null;
        this.topGames = [];
        this.recentGames = [];
      }

      resetStats() {
        if (confirm('Are you sure you want to reset all your stats? This cannot be undone.')) {
          localStorage.removeItem('chessTheoryLegionMerits');
          localStorage.removeItem('chessTheoryGamesPlayed');
          localStorage.removeItem('chessTheoryRecentBattleRanksMaster');
          localStorage.removeItem('chessTheoryRecentBattleRanksLichess');
          this.legionMerits = {};
          this.gamesPlayed = 0;
          this.recentBattleRanksMaster = [];
          this.recentBattleRanksLichess = [];
          this.render();
        }
      }

      async queryExplorer() {
        const fen = this.game.fen();
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, fen);
          const totalGames = (data.white || 0) + (data.draws || 0) + (data.black || 0);
          this.gameCount = totalGames;
          const countEl = document.getElementById('gameCount');
          if (countEl) {
            countEl.textContent = totalGames === 0 ? 'Position data temporarily unavailable ‚Äî continuing anyway...' : `This battle position was reached ${totalGames.toLocaleString()} times in history.`;
          }
        } catch (e) {
          console.error('Explorer query failed:', e);
          const countEl = document.getElementById('gameCount');
          if (countEl) countEl.textContent = 'Position data unavailable ‚Äî continuing anyway...';
        }
      }

      async handleClick(row, col) {
        if (this.game.turn() !== this.playerColor || this.game.game_over()) return;
        const square = 'abcdefgh'[col] + (8 - row);
        if (this.selected) {
          const moveOptions = { from: this.selected, to: square, promotion: 'q' };
          const preMoveFEN = this.game.fen();
          let move = this.game.move(moveOptions);
          if (move) {
            this.lastMove = { from: move.from, to: move.to };
            this.playerMoves++;
            const moveUCI = move.from + move.to + (move.promotion || '');
            await this.checkMoveQuality(preMoveFEN, moveUCI);
            this.previousFEN = null;
            this.lastPlayerUCI = null;
            this.selected = null;
            document.getElementById('theoryMessage').style.display = 'none';
            this.renderBoard();
            // Critical fix: trigger full render to activate AI logic
            setTimeout(() => this.render(), 100);
            return;
          }
          this.selected = null;
        }
        const piece = this.game.get(square);
        if (piece && piece.color === this.playerColor) {
          this.selected = square;
        }
        this.renderBoard();
      }

      async checkMoveQuality(prevFEN, playerUCI) {
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, prevFEN);
          if (data.moves && data.moves.length > 0) {
            const isTop3 = data.moves.slice(0, 3).some(m => m.uci === playerUCI);
            if (isTop3) this.topMoveChoices++;
          }
        } catch (e) {
          console.log('Move quality check failed:', e);
        }
      }

      async getHints() {
        if (this.hintUsed) return;
        const fen = this.game.fen();
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, fen);
          const topMoves = data.moves ? data.moves.slice(0, 5) : [];
          let commanderText = '';
          if (topMoves.length === 0) {
            commanderText = '<em>No moves available in database.</em>';
          } else {
            const moveNames = topMoves.map(m => m.san);
            const first = moveNames[0];
            const second = moveNames[1];
            const others = moveNames.slice(2);
            commanderText = `üéñÔ∏è <strong>Commander speaks:</strong><br><br>
            "Soldier, I have walked this battlefield before. I have seen this position play out many times.`;
            commanderText += ` If you wish to strike directly, march with <strong>${first}</strong> ‚Äî the most proven assault.`;
            if (second) commanderText += ` Or choose <strong>${second}</strong>, a solid formation trusted by many commanders.`;
            if (others.length > 0) {
              const othersList = others.join(', ');
              const pathWord = others.length === 1 ? 'path exists' : 'paths exist';
              commanderText += ` From the war journals, other ${pathWord}: <strong>${othersList}</strong> ‚Äî each leads to a different kind of struggle.`;
            }
            commanderText += ` I cannot fight for you. The next move is yours. Good luck."`;
          }
          const msgEl = document.getElementById('theoryMessage');
          msgEl.innerHTML = `<div style="font-size: 0.88rem; line-height: 1.7; margin-top: 8px;">${commanderText}</div>`;
          msgEl.style.display = 'block';
          this.hintUsed = true;
          const hintBtn = document.getElementById('hintBtn');
          if (hintBtn) {
            hintBtn.disabled = true;
            hintBtn.textContent = '‚úì Commander Consulted';
          }
        } catch (error) {
          const msgEl = document.getElementById('theoryMessage');
          msgEl.innerHTML = '<em>Unable to fetch hints ‚Äì try again.</em>';
          msgEl.style.display = 'block';
        }
      }

      async aiMove() {
        const fen = this.game.fen();
        if (this.lastAIMoveFEN === fen) return;
        this.lastAIMoveFEN = fen;
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, fen);
          const totalGames = (data.white || 0) + (data.draws || 0) + (data.black || 0);
          this.gameCount = totalGames;
          const minGames = this.aiSource === 'master' ? 5 : 20;
          if (totalGames < minGames || !data.moves || data.moves.length === 0) {
            const gamesData = await ChessAPI.queryGames(this.aiSource, fen);
            this.topGames = gamesData.topGames;
            this.recentGames = gamesData.recentGames;
            await this.stopGameDueToThinTheory();
            return;
          }
          let rand = Math.random() * totalGames;
          let cumulative = 0;
          let selectedMove = data.moves[0];
          for (const m of data.moves) {
            cumulative += m.white + m.draws + m.black;
            if (rand <= cumulative) {
              selectedMove = m;
              break;
            }
          }
          let move = null;
          if (selectedMove.san === 'O-O' || selectedMove.san === 'O-O-O') {
            move = this.game.move(selectedMove.san);
          } else {
            const uci = selectedMove.uci;
            move = this.game.move({ from: uci.slice(0,2), to: uci.slice(2,4), promotion: uci.length === 5 ? uci[4] : null });
          }
          if (move) {
            this.lastMove = { from: move.from, to: move.to };
            this.renderBoard();
            this.queryExplorer();
          } else {
            this.render(); // safeguard if move failed
          }
        } catch (error) {
          console.error('aiMove error:', error);
          this.render();
        }
      }

      async stopGameDueToThinTheory() {
        const fen = this.game.fen();
        const rawEval = await ChessAPI.getEvaluation(fen, this.evalCache);
        this.finalPlayerEval = Scoring.getPlayerEval(rawEval, this.playerColor);
        const { score, penaltyReason } = Scoring.getTotalScore(this.playerMoves, this.topMoveChoices, this.finalPlayerEval);
        const battleRank = Scoring.getBattleRank(score, this.finalPlayerEval, penaltyReason);
        const recentRanks = this.getRecentBattleRanks(this.aiSource);
        recentRanks.push(battleRank.title);
        if (recentRanks.length > 5) recentRanks.shift();
        this.setRecentBattleRanks(this.aiSource, recentRanks);
        this.updateLegionMerit(score);
        const moveQuality = Scoring.getMoveQuality(this.topMoveChoices, this.playerMoves);
        const displayEval = this.finalPlayerEval > 0 ? '+' + this.finalPlayerEval.toFixed(1) : this.finalPlayerEval.toFixed(1);
        const gamesToShow = this.aiSource === 'master' ? this.topGames : this.recentGames;
        const summaryEl = document.getElementById('endSummary');
        const msgEl = document.getElementById('theoryMessage');
        let demotionHtml = '';
        if (this.demotionMessage) {
          demotionHtml = `<div class="demotion-message">${this.demotionMessage}</div>`;
          this.demotionMessage = null;
        }
        let penaltyMsg = '';
        if (battleRank.penaltyReason) {
          penaltyMsg = `<div style="font-size: 0.95rem; color: #e74c3c; margin-top: 10px;">
            Penalty Applied: ${battleRank.penaltyReason}
          </div>`;
        }
        summaryEl.innerHTML = `
          ${demotionHtml}
          <div style="display: flex; justify-content: space-around; margin: 15px 0; font-size: 1rem; color: #81b64c; font-weight: bold;">
            <div>Moves: ${this.playerMoves}</div>
            <div>Quality: ${moveQuality}%</div>
            <div>Eval: ${displayEval}</div>
          </div>
          <div style="font-size: 1.8rem; margin: 15px 0;">
            ${battleRank.icon} ${battleRank.title}
          </div>
          ${penaltyMsg}
          <div style="font-size: 1.5rem; font-weight: bold; color: #81b64c; margin: 10px 0;">Battle Score: ${battleRank.score}/100</div>
          <div style="margin: 20px 0; padding: 15px; background: rgba(50, 50, 50, 0.6); border-radius: 10px;">
            <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 8px;">"${battleRank.msg}"</div>
            <div style="font-size: 0.95rem; color: #ccc;"><em>${battleRank.sub}</em></div>
          </div>
          <div class="rank-progress">
            ${['Levy', 'Hastatus', 'Principes', 'Triarius', 'Imperator'].map(r => `<div class="rank-step ${r === battleRank.title ? 'active' : ''}">${r}</div>`).join('')}
          </div>
          <div style="font-size: 0.9rem; color: #aaa; margin-top: 12px;">
            Tip: Deep theory + balanced position can reach Triarius & Imperator!
          </div>
        `;
        summaryEl.style.display = 'block';
        let html = `<strong>Games in this position:</strong> ${this.gameCount.toLocaleString()}<br><br>`;
        if (gamesToShow.length > 0) {
          gamesToShow.forEach((game, idx) => {
            const whitePlayer = game.white?.name || 'Unknown';
            const blackPlayer = game.black?.name || 'Unknown';
            const whiteRating = game.white?.rating || '?';
            const blackRating = game.black?.rating || '?';
            const year = game.year || '';
            const gameId = game.id || '';
            const gameUrl = gameId ? `https://lichess.org/${gameId}` : '#';
            let resultText = '';
            let resultColor = '#aaa';
            if (game.winner === 'white') {
              resultText = '1-0 White wins';
              resultColor = '#fff';
            } else if (game.winner === 'black') {
              resultText = '0-1 Black wins';
              resultColor = '#ccc';
            } else {
              resultText = '¬Ω-¬Ω Draw';
              resultColor = '#f1c40f';
            }
            html += `<div class="game-list-item">
              <strong>${idx + 1}.</strong> ${whitePlayer} (${whiteRating}) ‚Äì ${blackPlayer} (${blackRating})${year ? `, ${year}` : ''}<br>
              <span style="color: ${resultColor};">${resultText}</span><br>
              <a href="${gameUrl}" target="_blank" style="color: #81b64c; text-decoration: none;">View on Lichess ‚Üó</a>
            </div>`;
          });
        } else {
          html += '<em>No games found in this position.</em>';
        }
        msgEl.innerHTML = html;
        msgEl.style.display = 'block';
      }

      updateLegionMerit(score) {
        const meritKey = `${this.aiSource}_merit`;
        const oldMerit = this.legionMerits[meritKey] || 0;
        const oldLegionInfo = Scoring.getLegionRank(oldMerit);
        this.legionMerits[meritKey] = oldMerit + score;
        localStorage.setItem('chessTheoryLegionMerits', JSON.stringify(this.legionMerits));
        const newLegionInfo = Scoring.getLegionRank(this.legionMerits[meritKey]);
        if (newLegionInfo.title !== oldLegionInfo.title) {
          this.setRecentBattleRanks(this.aiSource, []);
        }
        this.gamesPlayed++;
        localStorage.setItem('chessTheoryGamesPlayed', this.gamesPlayed.toString());
        const currentMerit = this.legionMerits[meritKey] || 0;
        const legionInfo = Scoring.getLegionRank(currentMerit);
        if (legionInfo.title === 'Recruit') return;
        const weakRanks = this.getRecentBattleRanks(this.aiSource);
        const levyCount = weakRanks.filter(r => r === 'Levy').length;
        const hastatusCount = weakRanks.filter(r => r === 'Hastatus').length;
        const principesCount = weakRanks.filter(r => r === 'Principes').length;
        let shouldDemote = false;
        if (legionInfo.title === 'Legionary') {
          if (levyCount >= 3) shouldDemote = true;
        } else if (legionInfo.title === 'Optio') {
          if (levyCount >= 3 || (levyCount >= 2 && hastatusCount >= 1)) shouldDemote = true;
        } else if (legionInfo.title === 'Centurion' || legionInfo.title === 'Tribunus') {
          if ((levyCount + hastatusCount) >= 3) shouldDemote = true;
        } else if (legionInfo.title === 'Legatus') {
          if ((levyCount + hastatusCount + principesCount) >= 3) shouldDemote = true;
        }
        if (shouldDemote) {
          const rankOrder = legionInfo.rankOrder;
          const currentIndex = rankOrder.indexOf(legionInfo.title);
          if (currentIndex > 0) {
            const newRank = rankOrder[currentIndex - 1];
            const newMerit = currentIndex === 1 ? 0 : legionInfo.thresholds[currentIndex - 2];
            this.legionMerits[meritKey] = newMerit;
            localStorage.setItem('chessTheoryLegionMerits', JSON.stringify(this.legionMerits));
            this.setRecentBattleRanks(this.aiSource, []);
            this.demotionMessage = `Demoted to <strong>${newRank}</strong> for faltering command.<br>Merit reset to ${newMerit}. Reclaim your honor on the battlefield!`;
          }
        }
      }

      render() {
        if (!this.aiSource) {
          this.renderMenu();
          return;
        }
        if (!this.playerColor) {
          this.renderColorChoice();
          return;
        }
        this.renderBoard();
        this.queryExplorer();
        if (this.game.turn() !== this.playerColor) {
          const currentFEN = this.game.fen();
          if (this.lastAIMoveFEN !== currentFEN) {
            setTimeout(() => this.aiMove(), 800);
          }
        }
      }
    }

    new ChessTheoryApp();
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Lines of the Legion</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <style>
    .menu {
  max-width: 720px;
  margin: auto;
  padding: 28px 24px;
  background: linear-gradient(180deg, #111 0%, #0b0b0b 100%);
  border: 1px solid #222;
  border-radius: 12px;
  box-shadow: 0 20px 40px rgba(0,0,0,.6);
}
.battle-count {
  text-align: center;
  margin-top: 8px;     /* üëà was too large */
  margin-bottom: 6px;  /* üëà add this */
  font-size: .9rem;
  color: #bbb;
}

.menu-title {
  font-size: 2.2rem;
  letter-spacing: 0.08em;
  text-align: center;
  margin: 0 0 6px;
  color: #e5d8a8; /* parchment gold */
}

.menu-subtitle {
  text-align: center;
  font-size: 1rem;
  color: #aaa;
  max-width: 520px;
  margin: 0 auto 24px;
  line-height: 1.6;
}

    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background:linear-gradient(135deg,#0a0a0a 0%,#141414 100%);color:#eee;min-height:100vh;display:flex;flex-direction:column;align-items:center;padding:8px 12px;touch-action:manipulation}
    .menu h2{font-size:2rem;margin-bottom:12px;background:linear-gradient(135deg,#81b64c,#5d8a33);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .menu p{font-size:1rem;color:#ccc;margin-bottom:16px;line-height:1.5}
    .menu-btn{width:100%;padding:14px;margin:6px 0;background:linear-gradient(135deg,#81b64c,#5f8a35);color:#fff;border:none;border-radius:10px;font-size:1rem;font-weight:600;box-shadow:0 4px 0 #4a7028;cursor:pointer;transition:all .2s}
    .menu-btn:hover{transform:translateY(-1px);box-shadow:0 6px 0 #4a7028}
    .menu-btn:active{transform:translateY(2px);box-shadow:0 1px 0 #4a7028}
    #resetBtn{background:linear-gradient(135deg,#e74c3c,#c0392b);box-shadow:0 4px 0 #8b2e24}
    #resetBtn:hover{box-shadow:0 6px 0 #8b2e24}
    .game-container{max-width:460px;width:100%;background:rgba(20,20,20,.7);border-radius:16px;padding:14px;margin:10px 0;display:flex;flex-direction:column;gap:12px}
    .board-wrapper{width:100%;max-width:400px;aspect-ratio:1;display:grid;grid-template-columns:repeat(8,1fr);border:3px solid #222;border-radius:8px;align-self:center}
    .square{aspect-ratio:1;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:background .15s}
    .square.light{background:#f0d9b5}
    .square.dark{background:#b58863}
    .square.selected{background:#f6e58d!important;box-shadow:inset 0 0 0 4px #e67e22}
    .square.last-move{background:rgba(255,215,0,.45)!important}
    .square.disabled{pointer-events:none}
    .piece{width:84%;height:84%;filter:drop-shadow(0 2px 4px rgba(0,0,0,.6));pointer-events:none}
    .btn{padding:10px 18px;background:linear-gradient(135deg,#81b64c,#5f8a35);color:#fff;border:none;border-radius:8px;font-weight:600;font-size:.95rem;cursor:pointer;transition:all .2s}
    .btn:disabled{background:#444;opacity:.6;cursor:not-allowed}
    .info-line{font-size:.92rem;color:#bbb;text-align:center;margin:4px 0}
    .theory-message,.end-summary{background:rgba(35,35,35,.95);padding:12px 14px;border-radius:10px;font-size:.9rem;line-height:1.5;border:1px solid rgba(129,182,76,.2);max-height:320px;overflow-y:auto}
    .end-summary h3{font-size:1.1rem;margin-bottom:8px;color:#81b64c}
    .stats-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;text-align:center;margin:10px 0;font-size:.9rem}
    .stats-grid div strong{color:#81b64c}
   .rank-progress {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  justify-content: flex-start;   /* üëà THIS is the key */
  align-items: center;
}

    .rank-step{padding:4px 8px;border-radius:6px;background:rgba(50,50,50,.6);font-size:.8rem}
    .rank-step.active{background:linear-gradient(135deg,#81b64c,#5d8a33);color:#111;font-weight:bold}
    .battle-history{padding:10px 12px;background:rgba(40,40,40,.8);border-radius:10px;font-size:.85rem;border:1px solid rgba(129,182,76,.2)}
    .battle-history-title{font-size:.9rem;font-weight:bold;color:#81b64c;margin-bottom:6px}
    .battle-badges{display:flex;gap:6px;justify-content:center;flex-wrap:wrap}
    .battle-badge{padding:6px 10px;border-radius:6px;font-weight:bold;font-size:.85rem}
    .battle-badge.levy{background:#e74c3c}
    .battle-badge.hastatus{background:#e67e22}
    .battle-badge.principes{background:#f39c12;color:#222}
    .battle-badge.triarius{background:#27ae60}
    .battle-badge.imperator{background:#f1c40f;color:#222}
    .warning-message{background:rgba(231,76,60,.2);border:1px solid #e74c3c;padding:6px 10px;border-radius:8px;margin-top:8px;font-size:.75rem;line-height:1.3;color:#ff8888;font-weight:bold}
    .demotion-message,.promotion-message{background:rgba(200,30,30,.9);padding:12px;border-radius:10px;margin-bottom:12px;font-weight:bold;text-align:center;border:1px solid #ff4444;font-size:.85rem}
    .promotion-message{background:rgba(30,100,30,.9);border:1px solid #81b64c;color:#b8e986}
    .game-list-item{padding:10px;background:rgba(45,45,45,.8);border-radius:8px;margin-bottom:8px;font-size:.85rem}
    .game-list-item a{color:#81b64c;text-decoration:none}
    .author-note{font-size:.8rem;color:#777;text-align:center;margin-top:20px;font-style:italic}
    .action-buttons{display:flex;gap:10px;justify-content:center;margin-top:8px}
    .legion-card {
  margin: 16px 0;
  padding: 14px;
  border-radius: 12px;
  background: rgba(20,20,20,.9);
  border: 1px solid #2a2a2a;
}
.menu-cta {
  text-align: center;
  margin: 10px 0 8px;   /* üëà reduced */
  font-size: 1.05rem;
  color: #ccc;
}


.legion-card.masters {
  border-color: #3a3320;
  background: linear-gradient(180deg, #141209, #0c0b07);
}

.legion-card.club {
  border-color: #2a2a2a;
}

.legion-header {
  font-size: 1.05rem;
  font-weight: 700;
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.menu-actions {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin-bottom: 4px;  /* üëà reduce */
}


/* Primary campaign buttons */
.menu-btn.primary {
  width: 160px;
  padding: 12px 0;
  font-size: 1rem;
  font-weight: 600;
}

/* Reset = quiet, dangerous action */
.menu-btn.reset {
  width: auto;
margin: 2px auto 6px; 
  padding: 6px 12px;
  font-size: .8rem;
  background: transparent;
  border: 1px dashed #444;
  color: #888;
}

.menu-btn.reset:hover {
  color: #c66;
  border-color: #c66;
  background: rgba(120,30,30,.1);
}


.legion-status {
  font-size: .9rem;
  margin-bottom: 4px;
}

.legion-next {
  font-size: .8rem;
  color: #aaa;
  margin-bottom: 8px;
}

  </style>
</head>
<body>
  <div id="app"></div>
  <script>
    const pieces = {
      wp: "https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg",
      wr: "https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg",
      wn: "https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg",
      wb: "https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg",
      wq: "https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg",
      wk: "https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg",
      bp: "https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg",
      br: "https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg",
      bn: "https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg",
      bb: "https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg",
      bq: "https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg",
      bk: "https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg"
    };

    class ChessAPI {
      static cache = {};
      static async queryExplorer(source, fen) {
        const key = `${source}_${fen}`;
        if (this.cache[key]) return this.cache[key];
        let url = source === 'master' ? 'https://explorer.lichess.ovh/masters' : 'https://explorer.lichess.ovh/lichess';
        url += `?variant=standard&fen=${encodeURIComponent(fen)}&topGames=0&moves=5`;
        if (source === 'lichess') url += '&ratings=1600,1800,2000,2200,2500';
        try {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 6000);
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timeout);
          if (!response.ok) throw new Error('API error');
          const data = await response.json();
          this.cache[key] = data;
          return data;
        } catch (e) {
          console.warn('Explorer failed:', e);
          return { white: 0, draws: 0, black: 0, moves: [] };
        }
      }
      static async queryGames(source, fen) {
        const base = source === 'master' ? 'masters' : 'lichess';
        let url = `https://explorer.lichess.ovh/${base}?variant=standard&fen=${encodeURIComponent(fen)}`;
        if (source === 'master') url += '&topGames=10';
        else url += '&recentGames=10&ratings=1600,1800,2000,2200,2500';
        try {
          const response = await fetch(url);
          if (!response.ok) return { topGames: [], recentGames: [] };
          const data = await response.json();
          return { topGames: data.topGames || [], recentGames: data.recentGames || [] };
        } catch (e) {
          console.warn('Games query failed:', e);
          return { topGames: [], recentGames: [] };
        }
      }
      static async getEvaluation(fen, cache = {}) {
        if (cache[fen] !== undefined) return cache[fen];
        try {
          const response = await fetch('https://chess-api.com/v1', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fen })
          });
          if (response.ok) {
            const data = await response.json();
            if (typeof data.eval === 'number') {
              cache[fen] = data.eval;
              return data.eval;
            }
          }
        } catch (e) {
          console.log('Evaluation unavailable');
        }
        return 0;
      }
    }

    class Scoring {
      static getPlayerEval(e, c) { return c === 'b' ? -e : e; }
      static getMoveQuality(t, p) { return p > 0 ? Math.round((t / p) * 100) : 0; }
      static getTotalScore(m, t, e) {
        const ms = m * 4 * 0.25;
        const qs = this.getMoveQuality(t, m) * 0.40;
        const es = e < -3 ? 0 : Math.max(0, (e + 3) * 12 * 0.35);
        let b = ms + qs + es;
        let mul = 1, r = '';
        if (e < -3) { mul = 0.3; r = 'Total rout! The legions are shattered, banners fallen, the field lost in disgrace.'; }
        else if (e >= -3 && e < -1.5) { mul = 0.8; r = 'Broken lines! The cohort reels under heavy assault, fighting on but losing ground.'; }
        const s = Math.min(Math.round(b * mul), mul === 0.3 ? 30 : mul === 0.8 ? 60 : 100);
        return { score: s, penaltyReason: r };
      }
      static getBattleRank(s, e, r) {
        const t = [85, 70, 55, 40];
        let n;
        if (e <= -3) n = 'Levy';
        else if (e < -1.5) n = s >= t[3] ? 'Hastatus' : 'Levy';
        else n = s >= t[0] ? 'Imperator' : s >= t[1] ? 'Triarius' : s >= t[2] ? 'Principes' : s >= t[3] ? 'Hastatus' : 'Levy';
        const rks = {
  Levy: {
    icon: "ü™ì",
    title: "Levy",
    msg: r || "Thrown onto the field unblooded ‚Äî ranks break at first contact.",
    sub: "Fundamentals missing. Blunders erase all standing."
  },

  Hastatus: {
    icon: "üõ°Ô∏è",
    title: "Hastatus",
    msg: r || "You held the front line, shield locked, testing the enemy.",
    sub: "A sound beginning ‚Äî discipline and precision needed."
  },

  Principes: {
    icon: "‚öîÔ∏è",
    title: "Principes",
    msg: r || "You fought with order and purpose, pressing where it mattered.",
    sub: "Strong theory, reliable structure, few weaknesses."
  },

  Triarius: {
    icon: "ü¶Ö",
    title: "Triarius",
    msg: r || "When the battle wavered, you advanced and broke the stalemate.",
    sub: "Veteran-level command of position and timing."
  },

  Imperator: {
    icon: "üëë",
    title: "Imperator",
    msg: r || "Victory by design ‚Äî the battlefield bent to your will.",
    sub: "Flawless theory, flawless execution."
  }
}
        return { ...rks[n], score: s, penaltyReason: r };
      }
      static getLegionRank(m = 0) {
        const thresholds = [0, 100, 250, 500, 900, 1500];
        const rankOrder = ['Recruit', 'Legionary', 'Optio', 'Centurion', 'Tribunus', 'Legatus'];
        let level = 0;
        for (let i = 0; i < thresholds.length; i++) {
          if (m >= thresholds[i]) level = i;
          else break;
        }
        const title = rankOrder[level];
        const iconMap = { Recruit: "üå±", Legionary: "üõ°Ô∏è", Optio: "‚öîÔ∏è", Centurion: "ü¶Ö", Tribunus: "üèÖ", Legatus: "üèÜ" };
        let nextRank = null, pointsNeeded = 0;
        if (level < rankOrder.length - 1) {
          nextRank = rankOrder[level + 1];
          pointsNeeded = thresholds[level + 1] - m;
        }
        return {
          title,
          icon: iconMap[title],
          merit: m,
          nextRank,
          pointsNeeded,
          rankOrder,
          thresholds,
          level
        };
      }
      static getDemotionWarning(rankTitle, recentRanks) {
        if (rankTitle === 'Recruit' || recentRanks.length === 0) return null;
        const levy = recentRanks.filter(r => r === 'Levy').length;
        const hastatus = recentRanks.filter(r => r === 'Hastatus').length;
        const principes = recentRanks.filter(r => r === 'Principes').length;

        if (rankTitle === 'Legionary' && levy === 2) {
          return '‚öîÔ∏è Commander: Legionary, two Levy failures stain your record. One more = <span style="color:#e74c3c">stripped to Recruit!</span>';
        }
        if (rankTitle === 'Optio' && levy === 2) {
          return '‚öîÔ∏è Commander: Optio, two Levies mark your failures. One more Levy or Hastatus = <span style="color:#e74c3c">broken to Legionary!</span>';
        }
        if ((rankTitle === 'Centurion' || rankTitle === 'Tribunus') && (levy + hastatus) === 2) {
          return `‚öîÔ∏è Commander: ${rankTitle}, two weak battles disgrace your eagles. One more = <span style="color:#e74c3c">demoted to Optio!</span>`;
        }
        if (rankTitle === 'Legatus' && (levy + hastatus + principes) >= 2) {
          return '‚öîÔ∏è Commander: Legatus, your recent battles shame the legion. One more weak rank = <span style="color:#e74c3c">stripped of command!</span>';
        }
        return null;
      }
    }

    class ChessTheoryApp {
      constructor() {
        this.game = new Chess();
        this.playerColor = null;
        this.aiSource = null;
        this.selected = null;
        this.lastMove = { from: null, to: null };
        this.gameCount = 0;
        this.evalCache = {};
        this.lastAIMoveFEN = null;
        this.playerMoves = 0;
        this.topMoveChoices = 0;
        this.hintUsed = false;
        this.previousFEN = null;
        this.lastPlayerUCI = null;
        this.topGames = [];
        this.recentGames = [];
        this.pieceImages = pieces;
        this.legionMerits = JSON.parse(localStorage.getItem('chessTheoryLegionMerits') || '{}');
        this.gamesPlayed = parseInt(localStorage.getItem('chessTheoryGamesPlayed') || '0');
        this.recentBattleRanksMaster = JSON.parse(localStorage.getItem('chessTheoryRecentBattleRanksMaster') || '[]');
        this.recentBattleRanksLichess = JSON.parse(localStorage.getItem('chessTheoryRecentBattleRanksLichess') || '[]');
        this.rankChangeMessage = null;
        this.rankChanged = false;
        this.render();
      }

      getRecentBattleRanks(source) {
        return source === 'master' ? this.recentBattleRanksMaster : this.recentBattleRanksLichess;
      }
      setRecentBattleRanks(source, ranks) {
        if (source === 'master') {
          this.recentBattleRanksMaster = ranks;
          localStorage.setItem('chessTheoryRecentBattleRanksMaster', JSON.stringify(ranks));
        } else {
          this.recentBattleRanksLichess = ranks;
          localStorage.setItem('chessTheoryRecentBattleRanksLichess', JSON.stringify(ranks));
        }
      }

      renderBattleHistory(source) {
        const meritKey = `${source}_merit`;
        const currentMerit = this.legionMerits[meritKey] || 0;
        const legionInfo = Scoring.getLegionRank(currentMerit);
        const recentRanks = this.getRecentBattleRanks(source);
        const warning = Scoring.getDemotionWarning(legionInfo.title, recentRanks);

        if (recentRanks.length === 0) return '';

        const battleBadges = recentRanks.map(rank => {
          const letter = rank[0];
          const className = rank.toLowerCase();
          return `<div class="battle-badge ${className}">${letter}</div>`;
        }).join('');

        return `
          <div class="battle-history">
            <div class="battle-history-title">Last ${recentRanks.length} Battle${recentRanks.length > 1 ? 's' : ''}</div>
            <div class="battle-badges">${battleBadges}</div>
            ${warning ? `<div class="warning-message">${warning}</div>` : ''}
          </div>
        `;
      }

      renderMenu() {
        const masterMerit = this.legionMerits.master_merit || 0;
        const clubMerit = this.legionMerits.lichess_merit || 0;
        const masterLegion = Scoring.getLegionRank(masterMerit);
        const clubLegion = Scoring.getLegionRank(clubMerit);
        const masterBattleHistory = this.renderBattleHistory('master');
        const clubBattleHistory = this.renderBattleHistory('lichess');
        document.getElementById('app').innerHTML = `
          <div class="menu">
            <h1 class="menu-title">LINES OF THE LEGION</h1>

            <p class="menu-subtitle">
  Hold the line. Survive the opening drawn from real games ‚Äî
  until theory ends and true battle begins.
</p>

            <div style="font-size:.9rem;line-height:1.5;">
              <div class="legion-card masters">
  <div class="legion-header">üèÜ Masters Legion</div>
  <div class="legion-status">
    ${masterLegion.title} (${masterMerit} merit) ${masterLegion.icon}
  </div>
  ${masterLegion.nextRank
    ? `<div class="legion-next">${masterLegion.title} ‚Üí ${masterLegion.nextRank}: ${masterLegion.pointsNeeded} more</div>`
    : `<div class="legion-next">Highest rank achieved</div>`}
  <div class="rank-progress">
    ${masterLegion.rankOrder.map(r =>
      `<div class="rank-step ${r === masterLegion.title ? 'active' : ''}">${r}</div>`
    ).join('')}
  </div>
  ${masterBattleHistory}
</div>

<div class="legion-card club">
  <div class="legion-header">‚ôüÔ∏è Club Legion</div>
  <div class="legion-status">
    ${clubLegion.title} (${clubMerit} merit) ${clubLegion.icon}
  </div>
  ${clubLegion.nextRank
    ? `<div class="legion-next">${clubLegion.title} ‚Üí ${clubLegion.nextRank}: ${clubLegion.pointsNeeded} more</div>`
    : `<div class="legion-next">Highest rank achieved</div>`}
  <div class="rank-progress">
    ${clubLegion.rankOrder.map(r =>
      `<div class="rank-step ${r === clubLegion.title ? 'active' : ''}">${r}</div>`
    ).join('')}
  </div>
  ${clubBattleHistory}
</div>

              <div style="margin-top:8px;">‚öîÔ∏è Battles Fought: ${this.gamesPlayed}</div>
            </div>
            <p class="menu-cta">Choose your campaign:</p>

<div class="menu-actions">
  <button id="masterBtn" class="menu-btn primary">ü•∑ Master</button>
  <button id="lichessBtn" class="menu-btn primary">ü§∫ Club Rookie</button>
</div>

<button id="resetBtn" class="menu-btn reset">‚Ü∫ Reset Progress</button>

        
        `;
        document.getElementById('masterBtn').onclick = () => this.selectSource('master');
        document.getElementById('lichessBtn').onclick = () => this.selectSource('lichess');
        document.getElementById('resetBtn').onclick = () => this.resetStats();
      }

      renderColorChoice() {
        document.getElementById('app').innerHTML = `
          <div class="menu">
            <h2>Play As</h2>
            <div style="display:flex;gap:12px;justify-content:center;margin-top:16px;">
              <button id="whiteBtn" class="menu-btn" style="background:#f8f8f8;color:#222;flex:1;">White</button>
              <button id="blackBtn" class="menu-btn" style="background:#333;flex:1;">Black</button>
            </div>
          </div>
        `;
        document.getElementById('whiteBtn').onclick = () => this.selectColor('w');
        document.getElementById('blackBtn').onclick = () => this.selectColor('b');
      }

      renderGameContainer() {
        if (document.querySelector('.game-container')) return;
        document.getElementById('app').innerHTML = `
          <div class="game-container">
            <div class="board-wrapper" id="board"></div>
            <div class="info-line" id="gameCount">Loading position data...</div>
            <div id="endSummary" class="end-summary" style="display:none;"></div>
            <div id="theoryMessage" class="theory-message" style="display:none;"></div>
            <div class="action-buttons">
              <button class="btn" onclick="location.reload()">üîÑ New Battle</button>
              <button class="btn" id="hintBtn">üéñÔ∏è Consult Commander</button>
            </div>
          </div>
        `;
      }

      renderBoard() {
        this.renderGameContainer();
        const board = this.game.board();
        const isFlipped = this.playerColor === 'b';
        const renderedBoard = isFlipped ? board.slice().reverse().map(r => r.slice().reverse()) : board;
        const isPlayerTurn = this.game.turn() === this.playerColor;
        const countEl = document.getElementById('gameCount');
        if (countEl) {
          countEl.textContent = this.gameCount > 0
            ? `Position reached ${this.gameCount.toLocaleString()} times`
            : 'Position data unavailable ‚Äî continuing...';
        }
        const hintBtn = document.getElementById('hintBtn');
        if (hintBtn) {
          hintBtn.disabled = !isPlayerTurn || this.hintUsed;
          hintBtn.textContent = this.hintUsed ? '‚úì Consulted' : 'üéñÔ∏è Consult Commander';
          hintBtn.onclick = isPlayerTurn && !this.hintUsed ? () => this.getHints() : null;
        }
        const boardEl = document.getElementById('board');
        if (!boardEl) return;
        boardEl.innerHTML = '';
        renderedBoard.forEach((row, r) => {
          row.forEach((square, c) => {
            const actualRow = isFlipped ? 7 - r : r;
            const actualCol = isFlipped ? 7 - c : c;
            const sqName = 'abcdefgh'[actualCol] + (8 - actualRow);
            const isLight = (actualRow + actualCol) % 2 === 0;
            const isSelected = this.selected === sqName;
            const isLastMove = this.lastMove.from === sqName || this.lastMove.to === sqName;
            const div = document.createElement('div');
            div.className = `square ${isLight ? 'light' : 'dark'} ${isSelected ? 'selected' : ''} ${isLastMove ? 'last-move' : ''} ${!isPlayerTurn ? 'disabled' : ''}`;
            div.onclick = () => this.handleClick(actualRow, actualCol);
            if (square) {
              const img = document.createElement('img');
              img.src = this.pieceImages[square.color + square.type];
              img.className = 'piece';
              div.appendChild(img);
            }
            boardEl.appendChild(div);
          });
        });
      }

      selectSource(source) {
        this.aiSource = source;
        this.render();
      }
      selectColor(color) {
        this.playerColor = color;
        this.hintUsed = false;
        this.resetGameState();
        this.render();
      }
      resetGameState() {
        this.game.reset();
        this.selected = null;
        this.lastMove = { from: null, to: null };
        this.gameCount = 0;
        this.playerMoves = 0;
        this.topMoveChoices = 0;
        this.hintUsed = false;
        this.previousFEN = null;
        this.lastPlayerUCI = null;
        this.lastAIMoveFEN = null;
        this.topGames = [];
        this.recentGames = [];
      }
      resetStats() {
        if (confirm('Are you sure you want to reset all your stats? This cannot be undone.')) {
          localStorage.removeItem('chessTheoryLegionMerits');
          localStorage.removeItem('chessTheoryGamesPlayed');
          localStorage.removeItem('chessTheoryRecentBattleRanksMaster');
          localStorage.removeItem('chessTheoryRecentBattleRanksLichess');
          this.legionMerits = {};
          this.gamesPlayed = 0;
          this.recentBattleRanksMaster = [];
          this.recentBattleRanksLichess = [];
          this.render();
        }
      }

      async queryExplorer() {
        const fen = this.game.fen();
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, fen);
          const totalGames = (data.white || 0) + (data.draws || 0) + (data.black || 0);
          this.gameCount = totalGames;
          const countEl = document.getElementById('gameCount');
          if (countEl) {
            countEl.textContent = totalGames === 0 ? 'Position data unavailable ‚Äî continuing...' : `Position reached ${totalGames.toLocaleString()} times`;
          }
        } catch (e) {
          console.error('Explorer query failed:', e);
        }
      }

      async handleClick(row, col) {
        if (this.game.turn() !== this.playerColor || this.game.game_over()) return;
        const square = 'abcdefgh'[col] + (8 - row);
        if (this.selected) {
          const moveOptions = { from: this.selected, to: square, promotion: 'q' };
          const preMoveFEN = this.game.fen();
          let move = this.game.move(moveOptions);
          if (move) {
            this.lastMove = { from: move.from, to: move.to };
            this.playerMoves++;
            const moveUCI = move.from + move.to + (move.promotion || '');
            await this.checkMoveQuality(preMoveFEN, moveUCI);
            this.selected = null;
            document.getElementById('theoryMessage').style.display = 'none';
            this.renderBoard();
            setTimeout(() => this.render(), 100);
            return;
          }
          this.selected = null;
        }
        const piece = this.game.get(square);
        if (piece && piece.color === this.playerColor) {
          this.selected = square;
        }
        this.renderBoard();
      }

      async checkMoveQuality(prevFEN, playerUCI) {
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, prevFEN);
          if (data.moves && data.moves.length > 0) {
            const isTop3 = data.moves.slice(0, 3).some(m => m.uci === playerUCI);
            if (isTop3) this.topMoveChoices++;
          }
        } catch (e) {}
      }

      async getHints() {
        if (this.hintUsed) return;
        const fen = this.game.fen();
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, fen);
          const topMoves = data.moves ? data.moves.slice(0, 5) : [];
          let commanderText = '';
          if (topMoves.length === 0) {
            commanderText = '<em>No moves available in database.</em>';
          } else {
            const moveNames = topMoves.map(m => m.san);
            const first = moveNames[0];
            const second = moveNames[1];
            const others = moveNames.slice(2);
            commanderText = `üéñÔ∏è <strong>Commander speaks:</strong><br><br>
            "Soldier, I have seen this position many times.`;
            commanderText += ` March with <strong>${first}</strong> ‚Äî the most proven line.`;
            if (second) commanderText += ` Or <strong>${second}</strong>, trusted by many.`;
            if (others.length > 0) {
              const othersList = others.join(', ');
              commanderText += ` Other paths: <strong>${othersList}</strong>.`;
            }
            commanderText += ` The choice is yours. Good luck."`;
          }
          const msgEl = document.getElementById('theoryMessage');
          msgEl.innerHTML = commanderText;
          msgEl.style.display = 'block';
          this.hintUsed = true;
          const hintBtn = document.getElementById('hintBtn');
          if (hintBtn) {
            hintBtn.disabled = true;
            hintBtn.textContent = '‚úì Consulted';
          }
        } catch (error) {
          document.getElementById('theoryMessage').innerHTML = '<em>Unable to fetch hints.</em>';
          document.getElementById('theoryMessage').style.display = 'block';
        }
      }

      async aiMove() {
        const fen = this.game.fen();
        if (this.lastAIMoveFEN === fen) return;
        this.lastAIMoveFEN = fen;
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, fen);
          const totalGames = (data.white || 0) + (data.draws || 0) + (data.black || 0);
          this.gameCount = totalGames;
          const minGames = this.aiSource === 'master' ? 5 : 20;
          if (totalGames < minGames || !data.moves || data.moves.length === 0) {
            const gamesData = await ChessAPI.queryGames(this.aiSource, fen);
            this.topGames = gamesData.topGames || [];
            this.recentGames = gamesData.recentGames || [];
            await this.stopGameDueToThinTheory();
            return;
          }
          let rand = Math.random() * totalGames;
          let cumulative = 0;
          let selectedMove = data.moves[0];
          for (const m of data.moves) {
            cumulative += m.white + m.draws + m.black;
            if (rand <= cumulative) {
              selectedMove = m;
              break;
            }
          }
          let move = null;
          if (selectedMove.san === 'O-O' || selectedMove.san === 'O-O-O') {
            move = this.game.move(selectedMove.san);
          } else {
            const uci = selectedMove.uci;
            move = this.game.move({ from: uci.slice(0,2), to: uci.slice(2,4), promotion: uci.length === 5 ? uci[4] : null });
          }
          if (move) {
            this.lastMove = { from: move.from, to: move.to };
            this.renderBoard();
            this.queryExplorer();
          }
        } catch (error) {
          console.error('aiMove error:', error);
        }
      }

      async stopGameDueToThinTheory() {
        const fen = this.game.fen();
        const rawEval = await ChessAPI.getEvaluation(fen, this.evalCache);
        this.finalPlayerEval = Scoring.getPlayerEval(rawEval, this.playerColor);
        const { score, penaltyReason } = Scoring.getTotalScore(this.playerMoves, this.topMoveChoices, this.finalPlayerEval);
        const battleRank = Scoring.getBattleRank(score, this.finalPlayerEval, penaltyReason);

        // Add current battle rank
        const recentRanks = this.getRecentBattleRanks(this.aiSource);
        recentRanks.push(battleRank.title);
        if (recentRanks.length > 5) recentRanks.shift();
        this.setRecentBattleRanks(this.aiSource, recentRanks);

        // Update merit (may clear recent ranks if rank change)
        this.updateLegionMerit(score);

        const moveQuality = Scoring.getMoveQuality(this.topMoveChoices, this.playerMoves);
        const displayEval = this.finalPlayerEval > 0 ? '+' + this.finalPlayerEval.toFixed(1) : this.finalPlayerEval.toFixed(1);
        const gamesToShow = this.aiSource === 'master' ? this.topGames : this.recentGames;

        const summaryEl = document.getElementById('endSummary');
        const msgEl = document.getElementById('theoryMessage');

        let rankChangeHtml = this.rankChangeMessage ? 
          (this.rankChangeMessage.includes('Promoted') 
            ? `<div class="promotion-message">${this.rankChangeMessage}</div>`
            : `<div class="demotion-message">${this.rankChangeMessage}</div>`) 
          : '';
        this.rankChangeMessage = null;

        let penaltyMsg = battleRank.penaltyReason ? `<div style="color:#e74c3c;font-size:.85rem;margin-top:6px;">Penalty: ${battleRank.penaltyReason}</div>` : '';

        summaryEl.innerHTML = `
          ${rankChangeHtml}
          <h3>${battleRank.icon} ${battleRank.title} ‚Ä¢ Score: ${battleRank.score}/100</h3>
          <div class="stats-grid">
            <div>Moves<br><strong>${this.playerMoves}</strong></div>
            <div>Quality<br><strong>${moveQuality}%</strong></div>
            <div>Eval<br><strong>${displayEval}</strong></div>
          </div>
          <div style="font-style:italic;color:#bbb;margin:8px 0;">"${battleRank.msg}"</div>
          <div style="font-size:.85rem;color:#aaa;"><em>${battleRank.sub}</em></div>
          <div class="rank-progress">
            ${['Levy', 'Hastatus', 'Principes', 'Triarius', 'Imperator'].map(r => `<div class="rank-step ${r === battleRank.title ? 'active' : ''}">${r}</div>`).join('')}
          </div>
          ${penaltyMsg}
        `;
        summaryEl.style.display = 'block';

        let html = `<strong>Historical games from this position:</strong><br>`;
        if (gamesToShow.length > 0) {
          gamesToShow.forEach((game, idx) => {
            const whitePlayer = game.white?.name || 'Unknown';
            const blackPlayer = game.black?.name || 'Unknown';
            const whiteRating = game.white?.rating || '?';
            const blackRating = game.black?.rating || '?';
            const year = game.year || '';
            const gameId = game.id || '';
            const gameUrl = gameId ? `https://lichess.org/${gameId}` : '#';
            let resultText = game.winner === 'white' ? '1-0' : game.winner === 'black' ? '0-1' : '¬Ω-¬Ω';
            let resultColor = game.winner === 'white' ? '#fff' : game.winner === 'black' ? '#ccc' : '#f1c40f';
            html += `<div class="game-list-item">
              <strong>${idx + 1}.</strong> ${whitePlayer} (${whiteRating}) ‚Äì ${blackPlayer} (${blackRating})${year ? `, ${year}` : ''}<br>
              <span style="color:${resultColor};">${resultText}</span> ‚Ä¢ <a href="${gameUrl}" target="_blank">View ‚Üó</a>
            </div>`;
          });
        } else {
          html += '<em style="color:#888;">No games found.</em>';
        }
        msgEl.innerHTML = html;
        msgEl.style.display = 'block';
      }

      updateLegionMerit(score) {
        const meritKey = `${this.aiSource}_merit`;
        const oldMerit = this.legionMerits[meritKey] || 0;
        const oldLegion = Scoring.getLegionRank(oldMerit);

        let newMerit = oldMerit + score;
        const tempLegion = Scoring.getLegionRank(newMerit);

        let rankChanged = false;

        // Promotion
        if (tempLegion.level > oldLegion.level) {
          newMerit = tempLegion.thresholds[tempLegion.level];
          this.rankChangeMessage = `‚öîÔ∏è Commander: Promoted to ${tempLegion.title}! Merit reset to legion standard. üèÖ`;
          rankChanged = true;
        }

        const newLegion = Scoring.getLegionRank(newMerit);

        // Demotion
        const recentRanks = this.getRecentBattleRanks(this.aiSource);
        const levyCount = recentRanks.filter(r => r === 'Levy').length;
        const hastatusCount = recentRanks.filter(r => r === 'Hastatus').length;
        const principesCount = recentRanks.filter(r => r === 'Principes').length;

        let demoted = false;
        if (newLegion.title === 'Legionary' && levyCount >= 3) demoted = true;
        else if (newLegion.title === 'Optio' && (levyCount >= 3 || (levyCount >= 2 && hastatusCount >= 1))) demoted = true;
        else if ((newLegion.title === 'Centurion' || newLegion.title === 'Tribunus') && (levyCount + hastatusCount) >= 3) demoted = true;
        else if (newLegion.title === 'Legatus' && (levyCount + hastatusCount + principesCount) >= 3) demoted = true;

        if (demoted && newLegion.level > 0) {
          const newLevel = newLegion.level - 1;
          const newRankTitle = newLegion.rankOrder[newLevel];
          newMerit = newLegion.thresholds[newLevel];
          this.rankChangeMessage = `‚öîÔ∏è Commander: Your failures demand punishment. You are demoted to ${newRankTitle}! Rise or perish!`;
          rankChanged = true;
        }

        // Clear recent battle ranks if rank changed
        if (rankChanged) {
          this.setRecentBattleRanks(this.aiSource, []);
        }

        this.legionMerits[meritKey] = newMerit;
        localStorage.setItem('chessTheoryLegionMerits', JSON.stringify(this.legionMerits));
        this.gamesPlayed++;
        localStorage.setItem('chessTheoryGamesPlayed', this.gamesPlayed.toString());
      }

      render() {
        if (!this.aiSource) {
          this.renderMenu();
          return;
        }
        if (!this.playerColor) {
          this.renderColorChoice();
          return;
        }
        this.renderBoard();
        this.queryExplorer();
        if (this.game.turn() !== this.playerColor) {
          const currentFEN = this.game.fen();
          if (this.lastAIMoveFEN !== currentFEN) {
            setTimeout(() => this.aiMove(), 800);
          }
        }
      }
    }

    new ChessTheoryApp();
  </script>
</body>
</html>
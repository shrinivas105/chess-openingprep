<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Lines of the Legion</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background:linear-gradient(135deg,#0a0a0a 0%,#141414 100%);color:#eee;min-height:100vh;display:flex;flex-direction:column;align-items:center;padding:8px 12px;touch-action:manipulation}
    .menu{max-width:460px;width:100%;background:rgba(25,25,25,.95);border-radius:16px;padding:20px 18px;margin:10px 0;box-shadow:0 8px 32px rgba(0,0,0,.6);border:1px solid rgba(129,182,76,.15)}
    .menu h2{font-size:2rem;margin-bottom:12px;background:linear-gradient(135deg,#81b64c,#5d8a33);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .menu p{font-size:1rem;color:#ccc;margin-bottom:16px;line-height:1.5}
    .menu-btn{width:100%;padding:14px;margin:6px 0;background:linear-gradient(135deg,#81b64c,#5f8a35);color:#fff;border:none;border-radius:10px;font-size:1rem;font-weight:600;box-shadow:0 4px 0 #4a7028;cursor:pointer;transition:all .2s}
    .menu-btn:hover{transform:translateY(-1px);box-shadow:0 6px 0 #4a7028}
    .menu-btn:active{transform:translateY(2px);box-shadow:0 1px 0 #4a7028}
    #resetBtn{background:linear-gradient(135deg,#e74c3c,#c0392b);box-shadow:0 4px 0 #8b2e24}
    #resetBtn:hover{box-shadow:0 6px 0 #8b2e24}
    .game-container{max-width:460px;width:100%;background:rgba(20,20,20,.7);border-radius:16px;padding:14px;margin:10px 0;display:flex;flex-direction:column;gap:12px}
    .board-wrapper{width:100%;max-width:400px;aspect-ratio:1;display:grid;grid-template-columns:repeat(8,1fr);border:3px solid #222;border-radius:8px;align-self:center}
    .square{aspect-ratio:1;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:background .15s}
    .square.light{background:#f0d9b5}
    .square.dark{background:#b58863}
    .square.selected{background:#f6e58d!important;box-shadow:inset 0 0 0 4px #e67e22}
    .square.last-move{background:rgba(255,215,0,.45)!important}
    .square.disabled{pointer-events:none}
    .piece{width:84%;height:84%;filter:drop-shadow(0 2px 4px rgba(0,0,0,.6));pointer-events:none}
    .btn{padding:10px 18px;background:linear-gradient(135deg,#81b64c,#5f8a35);color:#fff;border:none;border-radius:8px;font-weight:600;font-size:.95rem;cursor:pointer;transition:all .2s}
    .btn:disabled{background:#444;opacity:.6;cursor:not-allowed}
    .info-line{font-size:.92rem;color:#bbb;text-align:center;margin:4px 0}
    .theory-message,.end-summary{background:rgba(35,35,35,.95);padding:12px 14px;border-radius:10px;font-size:.9rem;line-height:1.5;border:1px solid rgba(129,182,76,.2);max-height:320px;overflow-y:auto}
    .end-summary h3{font-size:1.1rem;margin-bottom:8px;color:#81b64c}
    .stats-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;text-align:center;margin:10px 0;font-size:.9rem}
    .stats-grid div strong{color:#81b64c}
    .rank-display{font-size:1.4rem;margin:10px 0;display:flex;align-items:center;justify-content:center;gap:8px}
    .rank-progress{display:flex;gap:4px;justify-content:center;margin:8px 0}
    .rank-step{padding:4px 8px;border-radius:6px;background:rgba(50,50,50,.6);font-size:.8rem}
    .rank-step.active{background:linear-gradient(135deg,#81b64c,#5d8a33);color:#111;font-weight:bold}
    .battle-history{padding:10px 12px;background:rgba(40,40,40,.8);border-radius:10px;font-size:.85rem;border:1px solid rgba(129,182,76,.2)}
    .battle-history-title{font-size:.9rem;font-weight:bold;color:#81b64c;margin-bottom:6px}
    .battle-badges{display:flex;gap:6px;justify-content:center;flex-wrap:wrap}
    .battle-badge{padding:6px 10px;border-radius:6px;font-weight:bold;font-size:.85rem}
    .battle-badge.levy{background:#e74c3c}
    .battle-badge.hastatus{background:#e67e22}
    .battle-badge.principes{background:#f39c12;color:#222}
    .battle-badge.triarius{background:#27ae60}
    .battle-badge.imperator{background:#f1c40f;color:#222}
    .warning-message{background:rgba(231,76,60,.2);border:1px solid #e74c3c;padding:8px;border-radius:8px;margin-top:8px;font-size:.85rem;color:#ff8888;font-weight:bold}
    .demotion-message{background:rgba(200,30,30,.9);padding:12px;border-radius:10px;margin-bottom:12px;font-weight:bold;text-align:center;border:1px solid #ff4444;font-size:1rem}
    .game-list-item{padding:10px;background:rgba(45,45,45,.8);border-radius:8px;margin-bottom:8px;font-size:.85rem}
    .game-list-item a{color:#81b64c;text-decoration:none}
    .author-note{font-size:.8rem;color:#777;text-align:center;margin-top:20px;font-style:italic}
    .action-buttons{display:flex;gap:10px;justify-content:center;margin-top:8px}
  </style>
</head>
<body>
  <div id="app"></div>
  <script>
    const pieces = {
      wp: "https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg",
      wr: "https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg",
      wn: "https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg",
      wb: "https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg",
      wq: "https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg",
      wk: "https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg",
      bp: "https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg",
      br: "https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg",
      bn: "https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg",
      bb: "https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg",
      bq: "https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg",
      bk: "https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg"
    };

    // [All your existing classes: ChessAPI, Scoring, ChessTheoryApp remain unchanged]
    // ... (paste the entire script from your original code here ‚Äì no changes needed to logic)

    class ChessAPI {
      static cache = {};
      static async queryExplorer(source, fen) {
        const key = `${source}_${fen}`;
        if (this.cache[key]) return this.cache[key];
        let url = source === 'master' ? 'https://explorer.lichess.ovh/masters' : 'https://explorer.lichess.ovh/lichess';
        url += `?variant=standard&fen=${encodeURIComponent(fen)}&topGames=0&moves=5`;
        if (source === 'lichess') url += '&ratings=1600,1800,2000,2200,2500';
        try {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 6000);
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timeout);
          if (!response.ok) throw new Error('API error');
          const data = await response.json();
          this.cache[key] = data;
          return data;
        } catch (e) {
          console.warn('Explorer failed:', e);
          return { white: 0, draws: 0, black: 0, moves: [] };
        }
      }
      static async queryGames(source, fen) {
        const base = source === 'master' ? 'masters' : 'lichess';
        let url = `https://explorer.lichess.ovh/${base}?variant=standard&fen=${encodeURIComponent(fen)}`;
        if (source === 'master') url += '&topGames=10';
        else url += '&recentGames=10&ratings=1600,1800,2000,2200,2500';
        try {
          const response = await fetch(url);
          if (!response.ok) return { topGames: [], recentGames: [] };
          const data = await response.json();
          return { topGames: data.topGames || [], recentGames: data.recentGames || [] };
        } catch (e) {
          console.warn('Games query failed:', e);
          return { topGames: [], recentGames: [] };
        }
      }
      static async getEvaluation(fen, cache = {}) {
        if (cache[fen] !== undefined) return cache[fen];
        try {
          const response = await fetch('https://chess-api.com/v1', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fen })
          });
          if (response.ok) {
            const data = await response.json();
            if (typeof data.eval === 'number') {
              cache[fen] = data.eval;
              return data.eval;
            }
          }
        } catch (e) {
          console.log('Evaluation unavailable');
        }
        return 0;
      }
    }

    class Scoring {
      static getPlayerEval(e, c) { return c === 'b' ? -e : e; }
      static getMoveQuality(t, p) { return p > 0 ? Math.round((t / p) * 100) : 0; }
      static getTotalScore(m, t, e) {
        const ms = m * 4 * 0.25;
        const qs = this.getMoveQuality(t, m) * 0.40;
        const es = e < -3 ? 0 : Math.max(0, (e + 3) * 12 * 0.35);
        let b = ms + qs + es;
        let mul = 1, r = '';
        if (e < -3) { mul = 0.3; r = 'Catastrophic blunder! Position collapsed (eval < -3.0).'; }
        else if (e >= -3 && e < -1.5) { mul = 0.8; r = 'Significant disadvantage (eval -3.0 to -1.5).'; }
        const s = Math.min(Math.round(b * mul), mul === 0.3 ? 30 : mul === 0.8 ? 60 : 100);
        return { score: s, penaltyReason: r };
      }
      static getBattleRank(s, e, r) {
        const t = [85, 70, 55, 40];
        let n;
        if (e <= -3) n = 'Levy';
        else if (e < -1.5) n = s >= t[3] ? 'Hastatus' : 'Levy';
        else n = s >= t[0] ? 'Imperator' : s >= t[1] ? 'Triarius' : s >= t[2] ? 'Principes' : s >= t[3] ? 'Hastatus' : 'Levy';
        const rks = {
          Levy: { icon: "ü™∂", title: "Levy", msg: r || "You barely stepped onto the battlefield.", sub: "Blunders reset your rank." },
          Hastatus: { icon: "üõ°Ô∏è", title: "Hastatus", msg: r || "Frontline soldier holding formation.", sub: "Good start ‚Äî improve execution." },
          Principes: { icon: "‚öîÔ∏è", title: "Principes", msg: "You commanded with structure and intent.", sub: "Solid theory and tactics." },
          Triarius: { icon: "ü¶Ö", title: "Triarius", msg: "Veteran presence ‚Äî turning the tide.", sub: "Excellent mastery of opening & position." },
          Imperator: { icon: "üèÜ", title: "Imperator", msg: "Master of war ‚Äî architect of victory.", sub: "Perfect theory + execution." }
        };
        return { ...rks[n], score: s, penaltyReason: r };
      }
      static getLegionRank(m = 0) {
        const th = [100, 250, 500, 900, 1500];
        const ro = ['Recruit', 'Legionary', 'Optio', 'Centurion', 'Tribunus', 'Legatus'];
        let l = 0;
        for (let i = 0; i < th.length; i++) if (m >= th[i]) l = i + 1; else break;
        const n = ro[l];
        const rk = { Recruit: { title: "Recruit", icon: "üå±" }, Legionary: { title: "Legionary", icon: "üõ°Ô∏è" }, Optio: { title: "Optio", icon: "‚öîÔ∏è" }, Centurion: { title: "Centurion", icon: "ü¶Ö" }, Tribunus: { title: "Tribunus", icon: "üèÖ" }, Legatus: { title: "Legatus", icon: "üèÜ" } };
        let nr = null, pn = 0;
        if (l < ro.length - 1) { nr = ro[l + 1]; pn = th[l] - m; if (pn < 0) pn = 0; }
        return { ...rk[n], merit: m, nextRank: nr, pointsNeeded: pn, rankOrder: ro, thresholds: th };
      }
      static getDemotionWarning(r, b) {
        if (r === 'Recruit' || b.length === 0) return null;
        const l = b.filter(x => x === 'Levy').length;
        const h = b.filter(x => x === 'Hastatus').length;
        const p = b.filter(x => x === 'Principes').length;
        let w = null;
        if (r === 'Legionary') { if (l === 2) w = '‚ö†Ô∏è Warning: 2 Levy ranks - one more Levy = demotion!'; }
        else if (r === 'Optio') {
          if (l === 2) w = '‚ö†Ô∏è Warning: 2 Levy ranks - one more Levy (to make 3) OR one Hastatus = demotion!';
          else if (l === 1 && h === 1) w = '‚ö†Ô∏è Warning: 1 Levy + 1 Hastatus - one more Levy = demotion!';
        }
        else if (r === 'Centurion' || r === 'Tribunus') { if (l + h === 2) w = '‚ö†Ô∏è Warning: 2 weak battles (Levy/Hastatus) - one more = demotion!'; }
        else if (r === 'Legatus') { if (l + h + p === 2) w = '‚ö†Ô∏è Warning: 2 subpar battles - one more weak rank = demotion!'; }
        return w;
      }
    }

    class ChessTheoryApp {
      constructor() {
        this.game = new Chess();
        this.playerColor = null;
        this.aiSource = null;
        this.selected = null;
        this.lastMove = { from: null, to: null };
        this.gameCount = 0;
        this.evalCache = {};
        this.lastAIMoveFEN = null;
        this.playerMoves = 0;
        this.topMoveChoices = 0;
        this.hintUsed = false;
        this.previousFEN = null;
        this.lastPlayerUCI = null;
        this.topGames = [];
        this.recentGames = [];
        this.pieceImages = pieces;
        this.legionMerits = JSON.parse(localStorage.getItem('chessTheoryLegionMerits') || '{}');
        this.gamesPlayed = parseInt(localStorage.getItem('chessTheoryGamesPlayed') || '0');
        this.recentBattleRanksMaster = JSON.parse(localStorage.getItem('chessTheoryRecentBattleRanksMaster') || '[]');
        this.recentBattleRanksLichess = JSON.parse(localStorage.getItem('chessTheoryRecentBattleRanksLichess') || '[]');
        this.demotionMessage = null;
        this.render();
      }
      getRecentBattleRanks(source) {
        return source === 'master' ? this.recentBattleRanksMaster : this.recentBattleRanksLichess;
      }
      setRecentBattleRanks(source, ranks) {
        if (source === 'master') {
          this.recentBattleRanksMaster = ranks;
          localStorage.setItem('chessTheoryRecentBattleRanksMaster', JSON.stringify(ranks));
        } else {
          this.recentBattleRanksLichess = ranks;
          localStorage.setItem('chessTheoryRecentBattleRanksLichess', JSON.stringify(ranks));
        }
      }
      renderBattleHistory(source) {
        const meritKey = `${source}_merit`;
        const currentMerit = this.legionMerits[meritKey] || 0;
        const legionInfo = Scoring.getLegionRank(currentMerit);
        const recentRanks = this.getRecentBattleRanks(source);
        const warning = Scoring.getDemotionWarning(legionInfo.title, recentRanks);
        if (recentRanks.length === 0) return '';
        const battleBadges = recentRanks.map(rank => {
          const letter = rank[0];
          const className = rank.toLowerCase();
          return `<div class="battle-badge ${className}">${letter}</div>`;
        }).join('');
        return `
          <div class="battle-history">
            <div class="battle-history-title">Last ${recentRanks.length} Battle${recentRanks.length > 1 ? 's' : ''}</div>
            <div class="battle-badges">${battleBadges}</div>
            ${warning ? `<div class="warning-message">${warning}</div>` : ''}
          </div>
        `;
      }
      renderMenu() {
        const masterMerit = this.legionMerits.master_merit || 0;
        const clubMerit = this.legionMerits.lichess_merit || 0;
        const masterLegion = Scoring.getLegionRank(masterMerit);
        const clubLegion = Scoring.getLegionRank(clubMerit);
        const masterBattleHistory = this.renderBattleHistory('master');
        const clubBattleHistory = this.renderBattleHistory('lichess');
        document.getElementById('app').innerHTML = `
          <div class="menu">
            <h2>Lines of the Legion</h2>
            <p>Hold the line. Survive the opening battle drawn from real games ‚Äî until theory ends and novelty begins.</p>
            <div style="font-size:.9rem;line-height:1.5;">
              <div><strong>üèÜ Masters Legion:</strong> ${masterLegion.title} (${masterMerit} merit) ${masterLegion.icon}</div>
              ${masterLegion.nextRank ? `<div>${masterLegion.title} ‚Üí ${masterLegion.nextRank}: ${masterLegion.pointsNeeded} more</div>` : '<div>Highest rank achieved!</div>'}
              <div class="rank-progress">${masterLegion.rankOrder.map(r => `<div class="rank-step ${r === masterLegion.title ? 'active' : ''}">${r}</div>`).join('')}</div>
              ${masterBattleHistory}
              <div><strong>‚ôüÔ∏è Club Legion:</strong> ${clubLegion.title} (${clubMerit} merit) ${clubLegion.icon}</div>
              ${clubLegion.nextRank ? `<div>${clubLegion.title} ‚Üí ${clubLegion.nextRank}: ${clubLegion.pointsNeeded} more</div>` : '<div>Highest rank achieved!</div>'}
              <div class="rank-progress">${clubLegion.rankOrder.map(r => `<div class="rank-step ${r === clubLegion.title ? 'active' : ''}">${r}</div>`).join('')}</div>
              ${clubBattleHistory}
              <div style="margin-top:8px;">‚öîÔ∏è Battles Fought: ${this.gamesPlayed}</div>
            </div>
            <p style="margin:16px 0 12px;font-size:1rem;">I want to fight a,</p>
            <button id="masterBtn" class="menu-btn">üèÜ Master</button>
            <button id="lichessBtn" class="menu-btn">‚ôüÔ∏è Club Rookie</button>
            <button id="resetBtn" class="menu-btn">üîÑ Reset Stats</button>
            <div class="author-note">Author: Srinivas Kulkarni</div>
          </div>
        `;
        document.getElementById('masterBtn').onclick = () => this.selectSource('master');
        document.getElementById('lichessBtn').onclick = () => this.selectSource('lichess');
        document.getElementById('resetBtn').onclick = () => this.resetStats();
      }
      renderColorChoice() {
        document.getElementById('app').innerHTML = `
          <div class="menu">
            <h2>Play As</h2>
            <div style="display:flex;gap:12px;justify-content:center;margin-top:16px;">
              <button id="whiteBtn" class="menu-btn" style="background:#f8f8f8;color:#222;flex:1;">White</button>
              <button id="blackBtn" class="menu-btn" style="background:#333;flex:1;">Black</button>
            </div>
          </div>
        `;
        document.getElementById('whiteBtn').onclick = () => this.selectColor('w');
        document.getElementById('blackBtn').onclick = () => this.selectColor('b');
      }
      renderGameContainer() {
        if (document.querySelector('.game-container')) return;
        document.getElementById('app').innerHTML = `
          <div class="game-container">
            <div class="board-wrapper" id="board"></div>
            <div class="info-line" id="gameCount">Loading position data...</div>
            <div id="endSummary" class="end-summary" style="display:none;"></div>
            <div id="theoryMessage" class="theory-message" style="display:none;"></div>
            <div class="action-buttons">
              <button class="btn" onclick="location.reload()">üîÑ New Battle</button>
              <button class="btn" id="hintBtn">üéñÔ∏è Consult Commander</button>
            </div>
          </div>
        `;
      }
      renderBoard() {
        this.renderGameContainer();
        const board = this.game.board();
        const isFlipped = this.playerColor === 'b';
        const renderedBoard = isFlipped ? board.slice().reverse().map(r => r.slice().reverse()) : board;
        const isPlayerTurn = this.game.turn() === this.playerColor;
        const countEl = document.getElementById('gameCount');
        if (countEl) {
          countEl.textContent = this.gameCount > 0
            ? `Position reached ${this.gameCount.toLocaleString()} times`
            : 'Position data unavailable ‚Äî continuing...';
        }
        const hintBtn = document.getElementById('hintBtn');
        if (hintBtn) {
          hintBtn.disabled = !isPlayerTurn || this.hintUsed;
          hintBtn.textContent = this.hintUsed ? '‚úì Consulted' : 'üéñÔ∏è Consult Commander';
          hintBtn.onclick = isPlayerTurn && !this.hintUsed ? () => this.getHints() : null;
        }
        const boardEl = document.getElementById('board');
        if (!boardEl) return;
        boardEl.innerHTML = '';
        renderedBoard.forEach((row, r) => {
          row.forEach((square, c) => {
            const actualRow = isFlipped ? 7 - r : r;
            const actualCol = isFlipped ? 7 - c : c;
            const sqName = 'abcdefgh'[actualCol] + (8 - actualRow);
            const isLight = (actualRow + actualCol) % 2 === 0;
            const isSelected = this.selected === sqName;
            const isLastMove = this.lastMove.from === sqName || this.lastMove.to === sqName;
            const div = document.createElement('div');
            div.className = `square ${isLight ? 'light' : 'dark'} ${isSelected ? 'selected' : ''} ${isLastMove ? 'last-move' : ''} ${!isPlayerTurn ? 'disabled' : ''}`;
            div.onclick = () => this.handleClick(actualRow, actualCol);
            if (square) {
              const img = document.createElement('img');
              img.src = this.pieceImages[square.color + square.type];
              img.className = 'piece';
              div.appendChild(img);
            }
            boardEl.appendChild(div);
          });
        });
      }
      // [Rest of the class methods remain exactly the same as your original code]
      // ... (selectSource, selectColor, resetGameState, resetStats, queryExplorer, handleClick, checkMoveQuality, getHints, aiMove, stopGameDueToThinTheory, updateLegionMerit, render)

      selectSource(source) {
        this.aiSource = source;
        this.render();
      }
      selectColor(color) {
        this.playerColor = color;
        this.hintUsed = false;
        this.resetGameState();
        this.render();
      }
      resetGameState() {
        this.game.reset();
        this.selected = null;
        this.lastMove = { from: null, to: null };
        this.gameCount = 0;
        this.playerMoves = 0;
        this.topMoveChoices = 0;
        this.hintUsed = false;
        this.previousFEN = null;
        this.lastPlayerUCI = null;
        this.lastAIMoveFEN = null;
        this.topGames = [];
        this.recentGames = [];
      }
      resetStats() {
        if (confirm('Are you sure you want to reset all your stats? This cannot be undone.')) {
          localStorage.removeItem('chessTheoryLegionMerits');
          localStorage.removeItem('chessTheoryGamesPlayed');
          localStorage.removeItem('chessTheoryRecentBattleRanksMaster');
          localStorage.removeItem('chessTheoryRecentBattleRanksLichess');
          this.legionMerits = {};
          this.gamesPlayed = 0;
          this.recentBattleRanksMaster = [];
          this.recentBattleRanksLichess = [];
          this.render();
        }
      }
      async queryExplorer() {
        const fen = this.game.fen();
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, fen);
          const totalGames = (data.white || 0) + (data.draws || 0) + (data.black || 0);
          this.gameCount = totalGames;
          const countEl = document.getElementById('gameCount');
          if (countEl) {
            countEl.textContent = totalGames === 0 ? 'Position data unavailable ‚Äî continuing...' : `Position reached ${totalGames.toLocaleString()} times`;
          }
        } catch (e) {
          console.error('Explorer query failed:', e);
        }
      }
      async handleClick(row, col) {
        if (this.game.turn() !== this.playerColor || this.game.game_over()) return;
        const square = 'abcdefgh'[col] + (8 - row);
        if (this.selected) {
          const moveOptions = { from: this.selected, to: square, promotion: 'q' };
          const preMoveFEN = this.game.fen();
          let move = this.game.move(moveOptions);
          if (move) {
            this.lastMove = { from: move.from, to: move.to };
            this.playerMoves++;
            const moveUCI = move.from + move.to + (move.promotion || '');
            await this.checkMoveQuality(preMoveFEN, moveUCI);
            this.selected = null;
            document.getElementById('theoryMessage').style.display = 'none';
            this.renderBoard();
            setTimeout(() => this.render(), 100);
            return;
          }
          this.selected = null;
        }
        const piece = this.game.get(square);
        if (piece && piece.color === this.playerColor) {
          this.selected = square;
        }
        this.renderBoard();
      }
      async checkMoveQuality(prevFEN, playerUCI) {
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, prevFEN);
          if (data.moves && data.moves.length > 0) {
            const isTop3 = data.moves.slice(0, 3).some(m => m.uci === playerUCI);
            if (isTop3) this.topMoveChoices++;
          }
        } catch (e) {}
      }
      async getHints() {
        if (this.hintUsed) return;
        const fen = this.game.fen();
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, fen);
          const topMoves = data.moves ? data.moves.slice(0, 5) : [];
          let commanderText = '';
          if (topMoves.length === 0) {
            commanderText = '<em>No moves available in database.</em>';
          } else {
            const moveNames = topMoves.map(m => m.san);
            const first = moveNames[0];
            const second = moveNames[1];
            const others = moveNames.slice(2);
            commanderText = `üéñÔ∏è <strong>Commander speaks:</strong><br><br>
            "Soldier, I have seen this position many times.`;
            commanderText += ` March with <strong>${first}</strong> ‚Äî the most proven line.`;
            if (second) commanderText += ` Or <strong>${second}</strong>, trusted by many.`;
            if (others.length > 0) {
              const othersList = others.join(', ');
              commanderText += ` Other paths: <strong>${othersList}</strong>.`;
            }
            commanderText += ` The choice is yours. Good luck."`;
          }
          const msgEl = document.getElementById('theoryMessage');
          msgEl.innerHTML = commanderText;
          msgEl.style.display = 'block';
          this.hintUsed = true;
          const hintBtn = document.getElementById('hintBtn');
          if (hintBtn) {
            hintBtn.disabled = true;
            hintBtn.textContent = '‚úì Consulted';
          }
        } catch (error) {
          document.getElementById('theoryMessage').innerHTML = '<em>Unable to fetch hints.</em>';
          document.getElementById('theoryMessage').style.display = 'block';
        }
      }
      async aiMove() {
        const fen = this.game.fen();
        if (this.lastAIMoveFEN === fen) return;
        this.lastAIMoveFEN = fen;
        try {
          const data = await ChessAPI.queryExplorer(this.aiSource, fen);
          const totalGames = (data.white || 0) + (data.draws || 0) + (data.black || 0);
          this.gameCount = totalGames;
          const minGames = this.aiSource === 'master' ? 5 : 20;
          if (totalGames < minGames || !data.moves || data.moves.length === 0) {
            const gamesData = await ChessAPI.queryGames(this.aiSource, fen);
            this.topGames = gamesData.topGames;
            this.recentGames = gamesData.recentGames;
            await this.stopGameDueToThinTheory();
            return;
          }
          let rand = Math.random() * totalGames;
          let cumulative = 0;
          let selectedMove = data.moves[0];
          for (const m of data.moves) {
            cumulative += m.white + m.draws + m.black;
            if (rand <= cumulative) {
              selectedMove = m;
              break;
            }
          }
          let move = null;
          if (selectedMove.san === 'O-O' || selectedMove.san === 'O-O-O') {
            move = this.game.move(selectedMove.san);
          } else {
            const uci = selectedMove.uci;
            move = this.game.move({ from: uci.slice(0,2), to: uci.slice(2,4), promotion: uci.length === 5 ? uci[4] : null });
          }
          if (move) {
            this.lastMove = { from: move.from, to: move.to };
            this.renderBoard();
            this.queryExplorer();
          }
        } catch (error) {
          console.error('aiMove error:', error);
        }
      }
      async stopGameDueToThinTheory() {
        const fen = this.game.fen();
        const rawEval = await ChessAPI.getEvaluation(fen, this.evalCache);
        this.finalPlayerEval = Scoring.getPlayerEval(rawEval, this.playerColor);
        const { score, penaltyReason } = Scoring.getTotalScore(this.playerMoves, this.topMoveChoices, this.finalPlayerEval);
        const battleRank = Scoring.getBattleRank(score, this.finalPlayerEval, penaltyReason);
        const recentRanks = this.getRecentBattleRanks(this.aiSource);
        recentRanks.push(battleRank.title);
        if (recentRanks.length > 5) recentRanks.shift();
        this.setRecentBattleRanks(this.aiSource, recentRanks);
        this.updateLegionMerit(score);
        const moveQuality = Scoring.getMoveQuality(this.topMoveChoices, this.playerMoves);
        const displayEval = this.finalPlayerEval > 0 ? '+' + this.finalPlayerEval.toFixed(1) : this.finalPlayerEval.toFixed(1);
        const gamesToShow = this.aiSource === 'master' ? this.topGames : this.recentGames;
        const summaryEl = document.getElementById('endSummary');
        const msgEl = document.getElementById('theoryMessage');
        let demotionHtml = this.demotionMessage ? `<div class="demotion-message">${this.demotionMessage}</div>` : '';
        this.demotionMessage = null;
        let penaltyMsg = battleRank.penaltyReason ? `<div style="color:#e74c3c;font-size:.85rem;margin-top:6px;">Penalty: ${battleRank.penaltyReason}</div>` : '';
        summaryEl.innerHTML = `
          ${demotionHtml}
          <h3>${battleRank.icon} ${battleRank.title} ‚Ä¢ Score: ${battleRank.score}/100</h3>
          <div class="stats-grid">
            <div>Moves<br><strong>${this.playerMoves}</strong></div>
            <div>Quality<br><strong>${moveQuality}%</strong></div>
            <div>Eval<br><strong>${displayEval}</strong></div>
          </div>
          <div style="font-style:italic;color:#bbb;margin:8px 0;">"${battleRank.msg}"</div>
          <div style="font-size:.85rem;color:#aaa;"><em>${battleRank.sub}</em></div>
          <div class="rank-progress">
            ${['Levy', 'Hastatus', 'Principes', 'Triarius', 'Imperator'].map(r => `<div class="rank-step ${r === battleRank.title ? 'active' : ''}">${r}</div>`).join('')}
          </div>
          ${penaltyMsg}
        `;
        summaryEl.style.display = 'block';
        let html = `<strong>Historical games from this position:</strong><br>`;
        if (gamesToShow.length > 0) {
          gamesToShow.forEach((game, idx) => {
            const whitePlayer = game.white?.name || 'Unknown';
            const blackPlayer = game.black?.name || 'Unknown';
            const whiteRating = game.white?.rating || '?';
            const blackRating = game.black?.rating || '?';
            const year = game.year || '';
            const gameId = game.id || '';
            const gameUrl = gameId ? `https://lichess.org/${gameId}` : '#';
            let resultText = game.winner === 'white' ? '1-0' : game.winner === 'black' ? '0-1' : '¬Ω-¬Ω';
            let resultColor = game.winner === 'white' ? '#fff' : game.winner === 'black' ? '#ccc' : '#f1c40f';
            html += `<div class="game-list-item">
              <strong>${idx + 1}.</strong> ${whitePlayer} (${whiteRating}) ‚Äì ${blackPlayer} (${blackRating})${year ? `, ${year}` : ''}<br>
              <span style="color:${resultColor};">${resultText}</span> ‚Ä¢ <a href="${gameUrl}" target="_blank">View ‚Üó</a>
            </div>`;
          });
        } else {
          html += '<em style="color:#888;">No games found.</em>';
        }
        msgEl.innerHTML = html;
        msgEl.style.display = 'block';
      }
      updateLegionMerit(score) {
        const meritKey = `${this.aiSource}_merit`;
        const oldMerit = this.legionMerits[meritKey] || 0;
        const oldLegionInfo = Scoring.getLegionRank(oldMerit);
        this.legionMerits[meritKey] = oldMerit + score;
        localStorage.setItem('chessTheoryLegionMerits', JSON.stringify(this.legionMerits));
        const newLegionInfo = Scoring.getLegionRank(this.legionMerits[meritKey]);
        if (newLegionInfo.title !== oldLegionInfo.title) {
          this.setRecentBattleRanks(this.aiSource, []);
        }
        this.gamesPlayed++;
        localStorage.setItem('chessTheoryGamesPlayed', this.gamesPlayed.toString());
        const currentMerit = this.legionMerits[meritKey] || 0;
        const legionInfo = Scoring.getLegionRank(currentMerit);
        if (legionInfo.title === 'Recruit') return;
        const weakRanks = this.getRecentBattleRanks(this.aiSource);
        const levyCount = weakRanks.filter(r => r === 'Levy').length;
        const hastatusCount = weakRanks.filter(r => r === 'Hastatus').length;
        const principesCount = weakRanks.filter(r => r === 'Principes').length;
        let shouldDemote = false;
        if (legionInfo.title === 'Legionary') {
          if (levyCount >= 3) shouldDemote = true;
        } else if (legionInfo.title === 'Optio') {
          if (levyCount >= 3 || (levyCount >= 2 && hastatusCount >= 1)) shouldDemote = true;
        } else if (legionInfo.title === 'Centurion' || legionInfo.title === 'Tribunus') {
          if ((levyCount + hastatusCount) >= 3) shouldDemote = true;
        } else if (legionInfo.title === 'Legatus') {
          if ((levyCount + hastatusCount + principesCount) >= 3) shouldDemote = true;
        }
        if (shouldDemote) {
          const rankOrder = legionInfo.rankOrder;
          const currentIndex = rankOrder.indexOf(legionInfo.title);
          if (currentIndex > 0) {
            const newRank = rankOrder[currentIndex - 1];
            const newMerit = currentIndex === 1 ? 0 : legionInfo.thresholds[currentIndex - 2];
            this.legionMerits[meritKey] = newMerit;
            localStorage.setItem('chessTheoryLegionMerits', JSON.stringify(this.legionMerits));
            this.setRecentBattleRanks(this.aiSource, []);
            this.demotionMessage = `Demoted to <strong>${newRank}</strong> for faltering command.<br>Merit reset to ${newMerit}. Reclaim your honor!`;
          }
        }
      }
      render() {
        if (!this.aiSource) {
          this.renderMenu();
          return;
        }
        if (!this.playerColor) {
          this.renderColorChoice();
          return;
        }
        this.renderBoard();
        this.queryExplorer();
        if (this.game.turn() !== this.playerColor) {
          const currentFEN = this.game.fen();
          if (this.lastAIMoveFEN !== currentFEN) {
            setTimeout(() => this.aiMove(), 800);
          }
        }
      }
    }
    new ChessTheoryApp();
  </script>
</body>
</html>